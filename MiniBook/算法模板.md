p style="text-align: center;font-size:50px">算法模板</p>
<p style="text-align: right;font-size:24px">BY Rainboy</p>

# 说明

`★`表示应该熟练掌握,能夠非常快速的写出代码,背下来

`☆`表示代码整理程度不完整,存在缺陷

`✡`表示超越NOIP难度


 - 高精度算法可能还是有问题
 - 注意看代码前面的说明,有些代码不能使用,
 - 还是有一部分的代码没有加入:RMQ,树状数组


## 排序算法

### 冒泡排序

一句话算法：第一趟循环len-1次,第二趟循环len-2次,第i趟循环len-i次

```c
int a[10]= {0,3,2,4,9,1,5,7,6,8};
for(i=1;i<=n-1;i++)
    for(j=1;j<=n-i;j++)
       if(a[j] > a[j+1])   tmp =a[j],a[j] =a[j+1],a[j+1]=tmp;

```

### 归并排序

```c
int a[] ={1,7,3,6,5,2};
int tmp[100]; //临时存储的中间数组

void merge_sort(int s,int t){
    int mid,i,j,k;
    if(s==t) return ; //如果区间只有一个数,就返回
    mid = (s+t)>>1; //取中间的点
    merge_sort(s,mid);
    merge_sort(mid+1,t);

    i=s;
    j=mid+1;
    k=s;

    while(i<=mid && j<=t){
        if( a[i] <=a[j]){
            tmp[k]=a[i];k++;i++;
        } else {
            tmp[k]=a[j];j++;k++;
        }
    }

    while(i<=mid) { tmp[k]=a[i];k++;i++;};
    while(j<=t)   { tmp[k]=a[j];k++;j++;};

    for(i=s;i<=t;i++)
        a[i]=tmp[i];
}
```

归并排序可以求逆序对:**火柴棒排序**
**归并排序的交换次数就是这个数组的逆序对个数**

### ★快速排序

```c
int a[]={6,2,7,3,8,9};
void quicksort(int l,int r){
    if( l <=r ){
    int s=l,t=r;
    int key =a[l]; // 取第一个值为key
    while(s < t){
        while( s <t && a[t] >= key) --t;// 如果a[t] >= key,t下标不停变小,直到a[t] < key
        if(s < t) a[s++] = a[t];        //停下来的时候,看一看,是不是到中点,如果不是 交换值
        while(s<t && a[s] <= key) ++s;  //如果a[s] <= key  s的下标不停变大,直到a[s] > key
        if(s<t ) a[t--] = a[s];         //停下来的时候,看一看,是不是到了中点,如果不是,交换值
    }
    a[s] = key;                         //上面while停止的时候,一定是s ==t
    quicksort(l,s-1);
    quicksort(s+1,r);
}
}
```

### 其它排序 (基本用不到的算法,给出最简代码)

#### 1.桶排序

代码来自now,不能使用

```c
void bin_sort(int a[]){
	int n = sizeof(a)/sizeof(a[0]);
	int i;
	for(i=0;i<n;i++){
		将A[i]插到表B[floor(n*A[i])]中;
	}
	for(i=0;i<n-1){
		对表B[i]进行排序;
	}
	将表B[0],B[1],...,B[n-1]按顺序合并;
}

```



#### 2.插入排序

代码来自now,未验证

```c
# include <iostream>
# include <cstdio>
using namespace std;
 
int n;
int a[10];
 
void I_sort()
{
	for (int i=2;i<=n;++i)
	{
		a[0] = a[i];
		int j = i-1;
		while (j>=1 && a[j]>a[0])
		{
			a[j+1] = a[j];
			--j;
		}
		a[j+1] = a[0];
	}
}
 
int main()
{
	cin>>n;
	for (int i=1;i<=n;++i)
		cin>>a[i];
 
	I_sort();
 
	for (int i=1;i<=n;++i)
		cout<<a[i]<<' ';
 
	return 0;
}
```
#### 3.基数排序

暂缺,基数排序的代码较长

http://www.cnblogs.com/jingmoxukong/p/4311237.html

#### 4.计数排序

代码来自如下,未验证

http://www.cnblogs.com/kaituorensheng/archive/2013/02/23/2923877.html

```c
#include <stdio.h>
void COUNTINGSORT(int *A, int *B, int array_size, int k)
{
        int C[k+1], i, value, pos;
        for(i=0; i<=k; i++)
        {
            C[i] = 0;
        }
        for(i=0; i< array_size; i++)
        {
            C[A[i]] ++;
        }
        for(i=1; i<=k; i++)
        {
            C[i] = C[i] + C[i-1];
        }
        for(i=array_size-1; i>=0; i--)
        {
            value = A[i];
            pos = C[value];
            B[pos-1] = value;
            C[value]--;
        }
}

        
int main()
{
        int A[8] = {2, 5, 3, 0, 2, 3, 0, 3}, B[8], i;
        COUNTINGSORT(A, B, 8, 5);
        for (i=0; i<= 7; i++)
        {
            printf("%d ", B[i]);
        }
        printf("\n");
        return 0;
}
```

## 数学相关

### gcd

#### 递归实现 

```C
int gcd(int a,int b){
    if (b==0) return a;
    return gcd(b, a%b);
}
```

#### 非递归

```c

int gcd(int a,int b){
    int t;
    while(b != 0){
        t=a;a=b;b= t % b;
    }
    return a;
}

```

### ex_gcd 

代码没有经过严格的验证

```c
int ex_gcd(int a,int b,int c,int &x,int &y){
    if(b == 0){
        x=c/a;
        y=0;
        return a;
    }
    int ans = ex_gcd(b,a%b,c2,x,y);
    int tmp =x;
    x = y;
    y = tmp -a/b*y;
    return ans;
}
```


### 最小公倍数 LCM

```c
int lcm(int a,int b){
    /* 原理 a*b = lcm(a,b)*gcd(a,b) */
    return (a / gcd(a,b) *b); //注意先 除
    
}
```

### 解线性同余方程

可以求解同余方程$a≡c(mod m)，b≡c(mod n)$

将其化为$a=c+mx，b=c+ny$，作差得

$mx-ny=a-b$，从而化为线性不定方程解决

### 筛法求素数

2016-11-16 cwl 发现错误提出修改

```c
#include <cstdio>
#include <cstring>

bool f[100000010];
int su[100010];
int sj,n=0,i,j;

void ShaSuShu(){
    memset(f,1,sizeof(f));
    for (i=2;i<=sj;i++){ //筛选
        if(f[i]){
            for(j=i<<1;j<=sj;j+=i)
                f[j] =false;
        }
    }
    for (i=2;i<=sj;i++){
        if( f[i]){
            n++;
            su[n]=i; //保存
        }
    }
}

int main(){
    scanf("%d",&sj);
    ShaSuShu();
    int i;
    for(i=1;i<=n;i++)
        printf("%d ",su[i]);
    return 0;
}
```

### 一些常用递推公式


#### 1.加法原理与乘法原理

**1.加法原理：**做一件事情，完成它可以有$n$类办法，在第一类办法中有$m1$种不同的方法，在第二类办法中有$m2$种不同的方法，……，在第$n$类办法中有mn种不同的方法。那么完成这件事共有$N＝m1＋m2＋…＋mn$种不同的方法。

**2.乘法原理:**做一件事情，完成它需要分成n个步骤，做第一步有m1种不同的方法，做第二步有m2种不同的方法，……，做第n步有种mn不同的方法，那么完成这件事有$N＝m1m2…mn$种不同的方法。

**3.两个原理的区别：**一个与分类有关，一个与分步有关；加法原理是“分类完成”，乘法原理是“分步完成”。



#### 2.排列组合

**1.排列**

 - **概念：**从$n$个不同元素中，任取$m(m≤n)$个元素按照一定的顺序排成一列，叫做从$n$个不同元素中取出$m$个元素的一个排列。
 - **排列数：**从$n$个不同元素中取出$m(m≤n)$个元素的所有排列的个数，叫做从$n$个不同元素中取出$m$个元素的排列数，用符号
 - **计算公式：**$A_n^m=n(n-1)(n-2)......(n-m+1)=\frac{n!}{(n-m)!}$

**2.组合**

 - **概念：**从n个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合。
 - 组合数：从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的组合数，用符号$C_n^m$表示
 - **计算公式:**$C_n^m =\frac{ A_n^m}{m!}=\frac{n(n-1)(n-2)......(n-m+1)}{m!}=\frac{n!}{(n-m)!}$
 - **组合恒等式：**
  - ① $C_n^m=C_n^{n-m}$
  - ② $C_n^m=C_{n-1}^{m-1}+C_{n-1}^{m}$
  - ③ $C_n^n+C_{n+1}^n+C_{n+2}^n+...+C_{n+r}^n=C_{n+r+1}^{n+1}$
  - ④ $C_n^0+C_n^1+C_n^2+...+C_n^n=2^n$
  - ⑤ $C_n^0+C_n^2+C_n^4+...=C_n^1+C_n^3+C_n^5+...=2^{n-1}$

#### 3.高中数学知识补充

 - n个人围着一张圆桌坐在一起，共有(n－1)!种坐法。
 - 把r个相同的球放到n个不同颜色的盒子中去，共有$C_{n+r-1}^r$种方法
 - 从n个排成一排的数中取m个数，且数字之间互不相邻，共有$C_{n-m+1}^r$种取法

 
#### 4.二项式定理
 
公式:

$$(a+b)^n=C_n^0a^nb^0+C_n^1a^{n-1}b^1+......+C_n^ra^{n-r}b^r+......+C_n^na^{0}b^n$$

其中$a^{n-r}b^r$的二项式系数为C_n^r$

#### catalan 数列

Catalan数列:

$$
1，2，5，14，42，132，429……，
$$

通项公式:

$$ h(n) = C_{2n}^{n} /(n+1)$$

**应用:**

01串, 出栈序列

具体代码,随后给出

#### 5.鸽巢原理（抽屉原理）

 - 1.简单形式：如果n＋1个物体被放进n个盒子，那么至少有一个盒子包含两个或更多的物体。
 - 2.加强形式：令$q1，q2，…，qn$为正整数。如果将$q1＋q2＋…＋qn－n＋1$个物体放入n个盒子内，那么或者第一个盒子至少含有q1个物体，或者第二个盒子至少含有q2个物体，…，或者第n个盒子含有qn个物体
  - 推论1：m只鸽子进n个巢，至少有一个巢里有$m/n$只鸽子
  - 推论2：$n(m－1)＋1$只鸽子进n个巢，至少有一个巢内至少有m只鸽子。
  - 推论3：若$m1，m2，……，mn$是正整数，且$\frac{m_1+...+m_n}{n}>r-1$.则至少有一个不小于r。
 
#### 6.容斥原理

公式复杂,随后给出

#### 进制转换

**N进制转十进制(秦九韶算法)**

bit[] 对应的N进制位

top是bit[] 最高位的下标,下标从0开始


```c
int convertFrom(int base,int *bit,int top){
    int ans = 0;
    for(int i =top;i>=0;i--){
        ans*=base;
        ans+=bit[i];
    }
    return ans;
}


**十进制转K进制(短除法)**


bit[] 对应的N进制位
top是bit[] 最高位的下标,下标从0开始

```c
void convertTo(int num,int base,int *bit,int &top){
    top=-1;
    do{
        bit[++top] = num % base;//可以直接输出 num % base
        num/=base;
    }while(num>0);
}
```


### 组合相关算法

#### (1)加法递推  -- $O(n^2)$

使用的公式:

$$
C_{n}^{m} = C_{n-1}^{m-1}+C_{n-1}^{m}
$$

边界:

$$
C_n^0=C_n^n = 1
$$

这个也是二项式定理,杨辉三角

```c
int c[1001][1001]; //根据实际需要开数组,必要的时候彩高精度,
                   //具体看 高精度组合
............
memset(c,0,sizeof(c));
int i,j;
c[0][0] =1; //边界
for(i=1;i<=n;i++){
    c[i][0] = 1;
    for(j=1;j<=i;j++){
        c[i][j] = c[i-1][j-1]+c[i-1][j];
    }
}
```


#### (2)乘法递推  -- $O(n)$

```c
int c[1001]; //必要的时候使用组合高精
.............
c[0]=1;
if( m >n-m) m = n-m;
for(int i =1;i<=m;i++){
    c[i] = (n-i+1)*c[i-1] / i;
}

```

代码demo

https://www.jianguoyun.com/p/DWbWlTYQ4MjlBRjKlxU

## 一般组合的产生

从n个元素里取m个元素,有多少种取法,把所有的取法都输出

一个合法的组合有这样的特点:

<p style="text-align: center;font-size:24px">排在后面的数字一定严格大于左面的数字</p>

```c
#include <cstdio>

int n,m;

int stack[10000];
void print(){
    int i;
    for (i=1;i<=m;i++)
        printf("%d ",stack[i]);
    printf("\n");
}
void dfs(int depth,int p){
    if(depth == m+1){
        print();
        return ;
    }
    int i;
    /*  p+1 <= k <=n-(m-depth) */
    for (i=p+1;i<=n-(m-depth);i++){
        /* 由于后面的数一定比较前面的数大,不用标记 */
        stack[depth]=i;
        dfs(depth+1,i);
    }

}

int main(){
    scanf("%d%d",&n,&m);
    dfs(1,0);
    return 0;
}
```


## 全组合

有n个元素,求这n个数构成的集合的所有非空子集

```c
#include <cstdio>
int n;
int item[10001]={0};

void full_combinatiom(int pos,int val){
	int i;
	/* i < pos pos代表正要选的位置,还没有选*/
    for(i=1;i<pos;i++)//输出已有的值
        printf("%d ",item[i]);//进入函数就输出
    printf("\n");
	
    for(i=val;i<=n;i++){
        item[pos] = i;
		/*位置+1,当前可以选的最小值+1*/
        full_combinatiom(pos+1,i+1);
		
    }
}

int main(){
	
	n = 3;
	full_combinatiom(1,1);
	return 0;
}
```

**注:**可以用一个整数来表示一个集合或者组合,因为第一位不是0就是1:具体可以看容斥原理

## 由上一组合产生下一组合

 1. 从右边向左寻找可以往下取的元素的数,位置为j
 2. 数列的j位到n位的重取元素

  - 右边的元素一定严格大于左侧的元素
  -


代码有可能错误,但是思想正确,因为没有验证

```c
int a[M];//a[i] 字典序的最小排序
....

int j =m-1;
while((j >=0) && (a[j]==n-(m-1-j))) j--;
if( i >=0){
    a[j]++;
    int k;
    for(k=j+1;k<m;k++) 
        a[k]=a[k-1]+1;
}

```

### 排列相关算法


#### 排列数的计算

根据数学公式:

$$
n!=n \times (n-1) \times (n-2) \times ......\times 1
$$

```c
typedef long long LL;
LL n,ans=1;
scanf("%d",&ans);
while(n !=0){
    ans*=n;
    n-=1;
};
```


#### 全排列的产生

对数字`1-->n`进行排序,输出每一种排序方法

当然是用DFS,对每个位置进行试探.

DFS**原则:**

<p style="text-align: center;font-size:24px"><strong>在某个位置下,选一个没有被选过的数,边界是n</strong></p>


```c
#include <cstdio>
int n;
/* 0代表没有被使用过 */
bool vis[10000]={0}; 
/* 存数据 */
int stack[10000];

void print(){
    int i;
    for (i=1;i<=n;i++)
        printf("%d ",stack[i]);
    printf("\n");
}

void dfs(int depth){
    if( depth == n+1){
        print();
        return ;
    }
    int i;
    for (i=1;i<=n;i++){
        if( vis[i] == 0){//如果这个数没有用过,就用
            vis[i] = 1;
            stack[depth]=i;
			dfs(depth+1);
            vis[i] = 0; //设为没有用过,还可以给其它位置用
        }
    }
}

int main(){
    scanf("%d",&n);
    dfs(1);
    return 0;
}
```


## 由上一个排列产生下一个排列

 1. 从右往左寻找第一个小于右边的数,位置j.
 2. 在是位置上的右边寻找大于$a_j$r的最小数字$a_k$
 3. 将$a_j$与$a_k$的值进行交换
 4. 将数列的$j+1$位到$n$倒转

 代码没有验证

```c
int a[N];
int j,k,p,q,temp;

j=(n-1)-1;
while(( j<=0) && (a[j]>a[j+1])) j--;

if(j >=0){
    k=n-1;
    while(a[k] < a[j]) k--;
    swap(a[j],a[k]);
    for(p=j+1,q=n-1;p<q;p++,q--){
        swap(a[p],a[q]);
    }
}


```

## 判断素数

```c
bool isprime(int x){
    /* 应该存在 这样的数 sqrt(x) = x.999999*/
	int n = sqrt(x)+0.5;
	int i;
	for(i=2;i<=n;i++)
		if( x %i==0) return false;
	return true;
}
```
 
## 筛法产生素数

原始: 三个循环

```c
bool vis[N];
int primes[N],n=0;
memset(vis,0,sizeof(vis));
for(i=2;i<N;i++)
    for(j=i+i;j<=N;j+=i){
        vis[N] = true;
    }
for(i=2;i<=N;i++)
    if(!vis[i])
        primes[n++] = i;

```


优化: 两个循环

```c
bool vis[N];
int primes[N],n=0;
memset(vis,0,sizeof(vis));
for(i=2;i<=N;i++){
    if(!vis[i]){
        primes[n++] = i;
        for(j=i+i;j<=N;j+=i) vis[j] =true;
    }
}
```

#### Miller-Rabin随机性素数测试算法

代码模板

```c
typedef unsigned long long LL;

LL modular_multi(LL x,LL y,LL mo)
{
    LL t;
    x%=mo;
    for(t=0;y;x=(x<<1)%mo,y>>=1)
        if (y&1)
            t=(t+x)%mo;
    return t;
}

LL modular_exp(LL num,LL t,LL mo)
{
    LL ret=1,temp=num%mo;
    for(;t;t>>=1,temp=modular_multi(temp,temp,mo))
        if (t&1)
            ret=modular_multi(ret,temp,mo);
    return ret;
}

bool miller_rabbin(LL n)
{
    if (n==2)return true;
    if (n<2||!(n&1))return false;
    int t=0;
    LL a,x,y,u=n-1;
    while((u&1)==0) t++,u>>=1;
    for(int i=0;i<S;i++)//S是运行的次数 次数越多准确性越高
    {
        a=rand()%(n-1)+1;
        x=modular_exp(a,u,n);
        for(int j=0;j<t;j++)
        {
            y=modular_multi(x,x,n);
            if (y==1&&x;!=1&&x;!=n-1)
                return false;
            x=y;
        }
        if (x!=1)
            return false;
    }
    return true;
}

```

## 康拓展开

```
/*============================================================================
* Title : 康托展开 ver1.0
* Author: Rainboy
* Time  : 2016-06-03 17:49
* update: 2016-06-03 17:49
* © Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/
#include <cstdio>
#include <cstring>

/* 在我们用char 类型的数组的时候,把它定义的比实际使用的大一点
  (不然有可能会出现各种莫名奇妙的错误),因为
    字符串的末尾是'\0' 实际长度比较长一个单位,
*/
char str[100] = {'3','1','2','4','5','6','7','8'};

char lx[100] = {'1','2','3','4','5','6','7','8'};
bool isExit[10];
int fac[10];

/*str 字符串,strlen 总长度*/
int encoding(char str[],int len){
    int num =0,i,j;
    for(i=0;i<len;i++){
        int tmp = 0;
        for(j=i+1;j<len;j++)
            /* 有几个数比它小 */
            if(str[j] < str[i]) tmp++; 
        num += tmp*fac[len-i-1];
    }
    return num;
}

//
void decoding(int num,int len,char str[]){
    memset(isExit,0,sizeof(isExit));
    int i,j,cnt;
    for(i=0;i<len;i++){
        cnt = 0;
        int y = num / fac[len-i-1];
        num = num % fac[len-i-1];
        /* y+1 第y+1次数到它,y=0,第一次数到的数就是 */
        for(j=0;j<len;j++){
            if(!isExit[j]) {
                cnt++;
                if(cnt == y+1)
                    break;
            }
        }
        /* 写法二
        j=-1;
        while( cnt < y+1){
            if(!isExit[++j]) cnt++;
        }
        */
        isExit[j] = 1;
        str[i] = lx[j];
    }
}

int main(){
    int i,j;
    fac[0] =1;
    for(i=1;i<=8;i++)
        fac[i] = fac[i-1]*i;
    int ans = encoding(str,8);
    printf("%d\n",ans);
    char tmp[10] ={0};
    decoding(ans,8,tmp);
    printf("%s",tmp);
    return 0;
}
```

## 容斥原理

求数字`2,3,4`在`n`中的所有倍数的和对`4321`的余数,其中$n<=10^9$.

具体代码看如下:


```c
#include <cstdio>

int n;
int a[] = {2,3,4};

typedef long long LL;

const int cnt =3;
const int m =4321;

LL ans = 0;

int gcd(int a,int b){
	if(b ==0 )
		return a;
	int t;
	while( b != 0){
		t = a % b;
		a = b;
		b = t;
	}
	return a;
}


int lcm(int a,int b){
	return a / gcd(a,b) * b;
	
}
void work(){
	int i,j;
	int tot;//计 有几个1
	int x;//选了的数的积
	for(i=1;i<(1<<cnt);i++){
		tot =0;x=1;
		for(j=0;j<cnt;j++){
			if(i &(1<<j)){
				tot++;//算法有几个1
				x = lcm(x,a[j]);
			}
		}
		
		LL N = n / x;
		
		//1*x +2*x +3*x + ---- N*n  等差数列公式
		
		//LL sum = ((x%m+N*x%m)*N% m)/2;
		
		LL sum = ((x+N*x)*N/2) % m;
		if(tot &1)//奇数
			ans = (ans% m  + sum% m ) ;
		else
			ans = (ans  - sum% m ) % m ;
	}
}

int main(){
	scanf("%d",&n);
	work();
	printf("%lld",ans);
	return 0;
}
```

## 分解质因数

**方法一:** 不产生素数表,直接除,在**除干净**后换下一个因数,但是当n是素数的时候会很慢


```c
#include <cstdio>
int p[1000],a[1000];
int n =90;
int main(){
    int i=2;
    int k = -1;

    while(n>1){
        if(n % i ==0){
            p[++k]=i;
            a[k] = 0;
            while(n % i == 0) n/=i,a[k]++;
        }else 
            i++;
    /* 换下一个因数 */
    /* 当n % i==0为真,那么i肯定是质数 */
    }

    for(i=0;i<=k;i++){
        printf("%d ",p[i]);
    }
}
```

**方法二: **产生一个$[2,\sqrt{n}]$内的素数表,然后从2开始除.在**除干净**后换下一个因数

为什么要算到$\sqrt{n}$?因为一个数$n$如果超出$\sqrt{n}$仍未分解出因子,说明这个数一定是质数

以下两个代码不是很完美:通用性方面

```c
#include <cstdio>
#include <cmath>
#include <cstring>

//5000000 分解质因数

#define N 2500  //sqrt(5000000) = 2237
bool vis[N];
int primes[N],n=0;

void ptable(){
memset(vis,0,sizeof(vis));
int i,j;
for(i=2;i<=N;i++){
    if(!vis[i]){
        primes[n++] = i;
        for(j=i+i;j<=N;j+=i) vis[j] =true;
    }
}
}

int p[N],a[N],top;
int main(){
    top=-1;
    int i = 0,j;
    int x = 5000000;
    memset(a,0,sizeof(a));
    ptable();
    while( x>1 && i <=N ){
        int &t = primes[i];
        if(x % t == 0){//有这个因子
            p[++top] = t;
            a[top] = 0;
        
        while(x % t == 0) 
            x/=t,a[top]++;//有几个因子,除干净
        i++;
		if( i > N )
			p[++top] = x;
        }
		else {
			i++;
		if( i > N )
			p[++top] = x;
		}
    }
    
    /* 输出 */
    for(i=0;i<=top;i++){
        for(j=1;j<=a[i];j++)
            printf("%d ",p[i]);
    }
}
```

一个数组搞定

```c
#include <cstdio>
#include <cmath>
#include <cstring>

//5000000 分解质因数

#define N 2500  //sqrt(5000000) = 2237
bool vis[N];
int primes[N],n=0;

void ptable(){
memset(vis,0,sizeof(vis));
int i,j;
for(i=2;i<=N;i++){
    if(!vis[i]){
        primes[n++] = i;
        for(j=i+i;j<=N;j+=i) vis[j] =true;
    }
}
}

int p[N],a[N],top;
int main(){
	top=-1;
	int i = 0,j;
	int x = 10;
	memset(a,0,sizeof(a));
	ptable();
	while( x>1 && i <=N){
		int &t = primes[i];
		if(x % t == 0){//有这个因子
			p[++top] = t;
			x/=t;
		
		while(x % t == 0) 
			x/=t,p[++top] = t;//有几个因子,除干净
		i++;
		/* 如果 i >= sqrt(5000000) 那个x本身就是素数*/
		if( i > N )
			p[++top] = x;
		
		}
		else {
			i++;
		if( i > N )
			p[++top] = x;
		}
	}
	
	/* 输出 */
	for(i=0;i<=top;i++){
			printf("%d ",p[i]);
	}
}
```

### 欧拉函数

暂缺

### Pollard &#39;s rho algorithm

代码来自wiki百科

```c
#inlude <iostream>
using namespace std;
int gcd(int a, int b) {
	int remainder;
	while (b != 0) {
		remainder = a % b;
		a = b;
		b = remainder;
	}
	return a;
}

int main () {
	int number = 10403, x_fixed = 2, cycle_size = 2, x = 2, factor = 1;

	while (factor == 1) {
		for (int count=1;count <= cycle_size && factor <= 1;count++) {
			x = (x*x+1)%number;
			factor = gcd(x - x_fixed, number);
		}

		cycle_size *= 2;
		x_fixed = x;
	}
	cout << "\nThe factor is  " << factor;
}
```

## 表达式求值

暂缺


## 高精度 1.普通型 2.类类型 3.高精度比较

**1.普通型:**

```c
/*============================================================================
* Title : 朴素高精度加 ver 0.0.2 -修复一个小错误
* Author: Rainboy
* Time  : 2016-04-13 20:48
* update: 2016-06-05 11:02
* © Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/

/* 算法思想:
 *          用字符串来存数字,模拟运算过程,字符串最长255
 *  
 *  原理:
 *      123
 *   +  456
 *   -------
 *      579
 *
 * */
#include <cstdio>
#include <cstdlib>
#include <cstring>

char sa[1000],sb[1000];
int a[1000],b[1000],c[1000];
int la,lb,lc;

int main(){
    int i;

    scanf("%s%s",sa,sb);
    la =strlen(sa);
    lb =strlen(sb);

    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));

    for(i=0;i<la;i++)   a[la-1-i] = sa[i] -'0'; //倒序存储,个位在第0个位置
    for(i=0;i<lb;i++)   b[lb-1-i] = sb[i] -'0';

    lc = la>lb?la:lb;

    for(i=0;i<lc;i++){
        c[i+1] = (a[i]+b[i]+c[i]) /10; //先算c[i+1]
        c[i] = (a[i]+b[i]+c[i]) % 10;
        /*  也可以这样写
         *  c[i] = a[i]+b[i] +c[i];
         *  if(c[i] >=10){
         *      c[i+1] = 1;
         *      c[i]-=10;
         *  }
         * */
    }

    if(c[lc] > 0) lc++; //判断有没有进位
    for(i=lc-1;i>=0;i--)
        printf("%d",c[i]);
    return 0;
}
```

**亿/万进制高精度加法:**

```c
/*============================================================================
* Title : 高精度-亿进制
* Author: Rainboy
* Time  : 2016-05-09 09:17
* update: 2016-05-09 09:17
* ? Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/


#include <cstdio>
#include <cstring>

char sa[2500],sb[2500];

int a[1000],b[1000],c[1000];

int la,lb,lc;

const int base  = 8; //8个0,亿进制
const int base2 = 100000000;

/* 返加 位数 */
int str2num(char x[],int y[]){
    int i,j=0,k=1;
    int lenx= strlen(x);
    for(i=lenx-1;i>=0;i--){
        if(k==base2) j++,k=1;
        y[j] += k*(x[i]-'0');
        k*=10;
    }
    return j+1;
}

int main(){
    int i;
    scanf("%s%s",sa,sb);
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));

    /* 转换数字 */
    int lena = str2num(sa,a);
    int lenb = str2num(sb,b);

    /* 开始运算 */
    int lc = lena >lenb ?lena:lenb;//max(lx,ly)

    for(i=0;i<lc;i++){ // 这里是一个需要记忆的地方
        c[i+1] =(a[i]+b[i]+c[i])/(base2);
        c[i] = (a[i]+b[i]+c[i]) % base2;
    }

    if(c[lc] >0)
        lc++;

    //输出
    printf("%d",c[lc-1]);
    for(i=lc-2;i>=0;i--)
        printf("%08d",c[i]);

    return 0;
}
```


**朴素高精度减法**

```c
/*============================================================================
* Title : 朴素高精度减法
* Author: Rainboy
* Time  : 2016-04-14 11:06
* update: 2016-06-12 09:30
* ? Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/

/*  原理模拟减法
 *      
 *      过程:
 *        1. 读取字符串
 *        2. 保证sa>=sb ,a=sa,b=sb
 *        3. 运算 c=a-b
 * */
#include <cstdio>
#include <cstring>

char sa[250],sb[250]; // 存字符串
int a[250],b[250],c[250]; //数据存储

int jianfa(int x[],int y[],int len){
    int i;
    for(i=0;i<len;i++){
        if(x[i] < y[i]) {//借位
            x[i+1]--;
            c[i]=10+x[i]-y[i];
        }
        else{
            c[i]=x[i]-y[i];
        }
        /*
            这样写更快一点
            x[i+1]--;
            c[i] = 10+x[i]-y[i];
            x[i+1] += c[i] /10;
            c[i] = c[i] %10;
        */
    }

    //处理最高位
    int t = len-1;
    while(c[t] == 0 && t >= 0) t--;

    return t+1; //范围
}

int main(){
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));
    int la,lb,lc;
    int i;
    int *pa,*pb;
    /* 读取数据 */
    scanf("%s%s",sa,sb);

    /* 处理数据 */
    la = strlen(sa);
    lb = strlen(sb);

    for(i=0;i<la;i++)
        a[i] = sa[la-1-i] - '0';

    for(i=0;i<lb;i++)
        b[i] = sb[lb-1-i] -'0';

    /* 默认 a - b 我们一定保障 pa>=pb*/
    if(lb >la || (la== lb && strcmp(sa,sb)==-1)){ //满足这些条件 a < b
        printf("-");//flag;
        pa = b;pb = a;
        lc =lb;
    } 
    else {
        pa =a;pb=b;
        lc =la;
    }
    int len = jianfa(pa,pb,lc);

    /* 输出 */
    if(len ==0)
        printf("0");
    else {
        for(i=len-1;i>=0;i--)
            printf("%d",c[i]);
    }

    return 0;
}
```

**亿进制高精度减法**

```c
/*============================================================================
* Title : 亿进制高精度减法 
* Author: Rainboy
* Time  : 2016-04-14 11:06
* update: 2016-05-09 10:33
* © Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/

/*  原理模拟减法
 *      
 *      过程:
 *        1. 读取字符串
 *        2. 保证sa>=sb ,a=sa,b=sb
 *        3. 运算 c=a-b
 * */

#include <cstdio>
#include <cstring>

const int base =8;
const int base2 = 100000000;

char sa[250],sb[250]; // 存字符串

int a[250],b[250],c[250]; //数据存储

int jianfa(int x[],int y[],int len){
    int i;
    for(i=0;i<len;i++){
        if(x[i] < y[i]) {//借位
            x[i+1]--;
            c[i]=base2+x[i]-y[i];
        }
        else{
            c[i]=x[i]-y[i];
        }
    }

    //处理最高位
    int t = len-1;
    while(c[t] == 0 && t >= 0) t--;

    return t+1; //范围最后的位数
}

/* 返加 位数 */
/* 用这个 str2num x指向的数组长度比较实际使用的长度长一点*/
int str2num(char x[],int y[]){
    int i,j=0,k=1;
    int lenx= strlen(x);
    for(i=lenx-1;i>=0;i--){
        if(k==base2) j++,k=1;
        y[j] += k*(x[i]-'0');
        k*=10;
    }
    return j+1;
}
int main(){
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));
    int la,lb,lc;
    int i;
    int *pa,*pb;
    /* 读取数据 */
    scanf("%s%s",sa,sb);

    /* 处理数据 */
    str2num(sa,a);
    str2num(sb,b);

    la = strlen(sa);
    lb = strlen(sb);
    /* 默认 a - b 我们一定保障 a>b*/
    if(lb >la || (la== lb && strcmp(sa,sb)==-1)){ //满足这些条件 a < b
        printf("-");//flag;
        pa = b;pb = a;
        lc =lb;
    } 
    else {
        pa =a;pb=b;
        lc =la;
    }

    int len = jianfa(pa,pb,lc);

    /* 输出 */
    if(len == 0)
        printf("0");
    else {
        /*输出最高位*/
        printf("%d",c[len-1]);
        for(i=len-2;i>=0;i--)
            printf("%08d",c[i]);
    }

    return 0;
}
```

**朴素高精度乘法**

```
/*============================================================================
* Title : 朴素高精度乘法
* Author: Rainboy
* Time  : 2016-04-14 11:06
* update: 2016-05-09 10:33
* © Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/
/*  思想:
 *          模拟运算,a[]="123" b[] = "123"
 *          a[1]*b[1]  放在c[1+1]
 *          a[1]*b[0] 放在c[1+0]
 *  原理:
 *      a,b以0下标开始,a[i]*b[i]放在c[i+j]位置上
 * */
#include <cstdio>
#include <cstring>


char s1[250],s2[250]; // 存字符串

int a[250],b[250],c[250]; //数据存储

/* c= a*b 返回位数 */
int mul(int a[],int la,int b[],int lb,int c[]){
    int lc = la+lb;
    int i,j;
    for(i=0;i<la;i++){
        for(j = 0;j<lb;j++){
            c[i+j] =c[i+j] + a[i]*b[j];
        }
    }

    /* 一次处理 */
    for(i=0;i<lc;i++){
        c[i+1] = c[i+1] + c[i] / 10;
        c[i] = c[i] % 10;
    }
    /* 查找最高位 是哪个 */
    /* 最高位的下标只可是 lc-1 或者lc-2 ,如果a,b的最高位不为0 */
    if( c[lc-1] == 0 ) lc--;

    return lc; //返回长度
}

void str2num(char str[],int x[],int lx){
    int i;
    for(i=0;i<lx;i++)
        x[i] = str[lx-1-i] -'0';
}

int main(){
    scanf("%s%s",s1,s2);

    int la,lb,lc;
    int i;

    la = strlen(s1);
    lb = strlen(s2);
    if((la == 1 && s1[0] == '0') || (lb==1 && s2[0] == '0'))
        printf("0");
    else {
        str2num(s1,a,la);
        str2num(s2,b,lb);
        lc = mul(a,la,b,lb,c);
        for(i=lc-1;i>=0;i--)
            printf("%d",c[i]);
    }
    /* 处理最高位 */
    /* n位数 * m位数 ,最多有n+m位,最少n+m-1位 */
    return 0;
}
```

**万进制高精度乘法:**

```c
/*============================================================================
* Title : 万进制高精度乘法
* Author: Rainboy
* Time  : 2016-04-14 11:06
* update: 2016-06-12 10:11
* © Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/
/*  思想:
 *      四位一存
 * */
#include <cstdio>
#include <cstring>

char sa[250],sb[250]; // 存字符串

int a[250],b[250],c[250]; //数据存储

const int base = 4;
const int base2 =10000;

/* c= a*b 返回位数 */
int mul(int a[],int la,int b[],int lb,int c[]){
    int lc = la+lb;
    int i,j;
    for(i=0;i<la;i++){
        for(j = 0;j<lb;j++){
            c[i+j] =c[i+j] + a[i]*b[j];
        }
    }

    /* 一次处理 */
    for(i=0;i<lc;i++){
        c[i+1] = c[i+1] + c[i] / base2;
        c[i] = c[i] % base2;
    }
    /* 查找最高位 是哪个 */
    /* 最高位的下标只可是 lc-1 或者lc-2 ,如果a,b的最高位不为0 */
    if( c[lc-1] == 0 ) lc--;
    return lc; //返回长度
}

int str2num(char x[],int y[]){
    int i,j=0,k=1;
    int lenx= strlen(x);
    for(i=lenx-1;i>=0;i--){
        if(k==base2) j++,k=1;
        y[j] += k*(x[i]-'0');
        k*=10;
    }
    return j+1;
}

int main(){
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));

    scanf("%s%s",sa,sb);
    int la,lb,lc;
    int i;

    la = strlen(sa);
    lb = strlen(sb);
    if((la == 1 && sa[0] == '0') || (lb==1 && sb[0] == '0'))
        printf("0");
    else {
        la = str2num(sa,a);
        lb = str2num(sb,b);
        /* 处理最高位 */
        /* n位数 * m位数 ,最多有n+m位,最少n+m-1位 */
        lc = mul(a,la,b,lb,c);


        /* 输出最高位 */
        printf("%d",c[lc-1]);
        for(i=lc-2;i>=0;i--)
            printf("%04d",c[i]);
    }
    return 0;
}
```


**组合数高精,2.类类型 3.高精度比较** 

暂缺

## 贪心


## 一、贪心策略的基本思想

----------------

### (1).定义

贪心法是一种解决最优问题的策略。它是从问题的初始解出发，按照当前最佳的选择，把问题归纳为更小的相似的子问题，并使子问题最优，再由子问题来推导出全局最优解。


贪心是一种解题策略，也是一种解题思想


使用贪心方法需要注意局部最优与全局最优的关系，选择当前状态的局部最优并不一定能推导出问题的全局最优。

## 利用贪心策略解题，需要解决两个问题 

-------------------

### (1).怎么知道问题是否能用贪心策略求解

 - **贪心选择特性:**即通过局部的贪心选择来达到问题的全局最优解。
 - **最优子结构性质:**即原问题的最优解包含子问题的最优解。

### (2).如何选择贪心标准，以得到问题的最优解

## 搜索

分类

 - DFS 
  - DFS框架,裸搜
  - DFS+贪心
  - DFS剪枝
  - DFS+DP+(状态压缩) 记忆化搜索
  - DFS限界 -埃及分数
 - BFS
  - 双向BFS
  - A星算法

#### BFS框架

```c

```

## 分治

## 动态规划

----------------------

一句话概念:**DP就是子问题状态的迁移过程.**

解法步骤:

 - 确定问题是DP
 - 想出所有的DP状态
 - 想出状态是如果迁移的:状态转移方程
 - 具体做法
  - 状态的前趋很好找到--->递推的DP
  - 状态的前趋不好找到--->记忆化搜索

### 线性DP

线型动态规划问题,最典型的特征就是状态都在一条线上,并且位置固定,问题一般都规定只能从前往后取状态,解决的办法是根据前面的状态特征,选取最优状态作为决策进行转移。 
 - •设前 i个点的最优值,研究前 i-1 个点与前 i个点的最优值, 
 - •利用第 i个点决策转移   
状态转移方程一般可写成:

$$
f_i(k) = min\left \{ f_{i-1}\ or\ j( k') + u(i,j)\ or\ u(i,i-1) \right \} 
$$

#### (1).LIS 最长不下降子序列 ** $n^2$ **



```c
int a[100];
int f[100];
int LIS(int n){
    int i,j,ans=0;
    for (i=1;i<=n;i\){
        scanf("%d",&a[i]);
        f[i]=1;
    }
    
    for (i=2;i<=n;i++){
        for (j=1;j<=i-1;j++){
            if(a[i] > a[j])
                f[j] = max(f[i],f[j]+1);
        }
    }

    for (i=1;i<=n;i++){
        if(f[i] > ans)
            ans = f[x];
    }
    return ans;
}
```

**二分查找法 $n \times logn$** 代码由Riolu(2014)提供

```c
int a[n],c[n],f[n],m;
//a 为数组,f存最大长度
//c是符合条件的最长非降序列
//c[i]表示长度为i的LIS最小右端值

memset(c,0x7f,siezof);

int LIS(){
    int i;
    for(i=1;i<=n;i++){
        int min=1,max=i;

        while(min<max){     //寻找最大c[x],使c[x]<=a[i]
            int mid  = (min+max)>>1;
            if(c[mid] <= a[i])
                min = mid+1;
            else
                max= mid;
        }

        f[i]=min;   //保有答案
        c[min]=a[i];//更新最小值
        return f[n];
    }
}
```

#### (2).LCS 最长公共序列

**状态转移方程:**

$$
f(i,j) = 
\left\{\begin{matrix}
f(i-1,j)\\ 
f(i,j-1)\\ 
f(i-1,j-1)+a_i==b_j\ ?\ 1:0
\end{matrix}\right.
$$

```c
int f[1001][1001];

int LCS(int *a,int m,int *b,int n){ // m,n分别是a,b中元素的个数
    int i,j;
    memset(f,0,sizeof(f));
    for (i=1;i<=m;i++)
    for (j=1;j<=n;j++){
        if (a[i] == b[j]) f[i][j] = f[i-1][j-1]+1;
        f[i][j] = max(f[i][j],max(f[i-1][j],f[i][j-1]));
    }
}
```

#### 

### 区域型DP

 - **特征:**能将问题分解成为两两合并的形式 
 - **合并:**意思就是将两个或多个部分进行整合,当然也可以反过来,也就是是将一个问题进行分解成两个或多个部分.
 - **求解:**对整个问题设最优值,**枚举合并点**,将问题分解成为左右两个部分,最后将左右两个部分的最优值进行合并得到原问题的最优值。有点类似分治算法的解题思想。 
 - **典型试题:**整数划分,凸多边形划分、石子合并、多边形合并、能量项链等、数字游戏。

####  石子合并

### 树型DP

### 背包类DP

### 状态压缩

## 树

-----------



## 图论

----------

### 一: 图的存储

#### 一些基本说明

我们常用到的量

```c
int n,m;            //n代表点数,m代表边数
int G[N][N];
int u[M],v[M],w[M];
int first[N],next[M];
vector<int> g[N];
edge *adj[N];
const int INF = 0x7fffffff/3;
```


##### (1).邻接矩阵

二维数组`G[N][N]`

其中如果  边`<i,j>`不存在,`G[i][j] = INF`,当然`G[i][i] = INF`

##### (2). 邻接表(动态化静态)


##### (3).边集数组

```c
int first[N];
int u[M],v[M],w[M],next[M];

memset(first,-1,sizeof(first));
for(e=1;e<=m;e++){
    scanf("%d%d%d",&u[e],&v[e],&w[e]);
    next[e] = first[u[e]];
    first[u[e]] = e;
}
```

访问所有点a的相临点

```c
int e;
for(e=first[a];e!=-1;e=next[e]){
    //TODO 
    //v[e] ,a的相临点
}
```

##### (4).邻接表 -STL实现


```c
vector<int> g[n];
int e;
int u[M],v[M],w[M];

for(e=1;e<=m;e++){
    scanf("%d%d%d",&u[e],&v[e],&w[e]);
    g[ u[e] ].push_back(e);
}

```

想找出点a的相临点

```c
int i;
for(i=0;i<=g[a].size();i++){
    int &e = g[a][i]; //得到哪一条边
    //u[e]起点,v[e]是终点,w[e]权
}
```
### 二: 图的遍历

#### (1).BFS

```c
#define N 100;
queue<int> q; //队列
bool vis[N]=0;

void BFS(int s){
    q.push(s);vis[s] =1; //起点入队,设为已访问
    do{
        int a = q.front(); q.pop(); //取头点
        printf("%d ",a);
        int i;
        for(i=1;i<=n;i++){
            if(!vis[i] && G[a][i] !=INF){ //没有访问过,且相连
                q.push(i);//入队
                vis[a]=1;//设为已经访问过
            }
        }while(!q.empty());
    }
}
```
#### (2).DFS

```c
#define N 101  // 定义一个最大点量
#define M 101  // 最在边量
int n,m;

const int INF = 0x7fffffff / 3;

int G[N][N];
bool vis[N] = {0}; // 全设为没有被访问过
void DFS(int x){
    vis[x] = true;//设为已经访问过
    printf("%c ",x); //输出x

    int i;
    for(i=1;i<=n;i++){
        if( !vis[i]  && G[x][i] != INF) //和x相临且没有被访问过的点
            DFS(i);
    }
}

```

### 三: 最短路径

#### (1).Floyd-Warshall $$O(n^3)$$

```c
/*  floyd 算法的本质:DP
 *      f(i,j) = min{f(i,k)+f{k,j}}
 *  floyd算法的原理: i,j 经过中间点k的最短路径
 * */
#include <cstdio>
#include <cstring>

#define N 100
const int INF = 0x7fffffff/3;
int f[N][N],pre[N][N]; //pre 记录前趋
int n,m;//n个点,m条边
int s,t;//起点 终点

void floyd(){
    int k,i,j;
    for(k=1;k<=n;k++){ //k在最外层
        for (i=1;i<=n;i++) //枚举 任意的其它点
            for(j=1;j<=n;j++)
                if(f[i][k]+f[k][j]<f[i][j]){
                    f[i][j] = f[i][k]+f[k][j];
                    pre[i][j]=k;
                }
    }
}
```

#### (1.1).Floyd-Warshall求最小环

#### (2).Dijkstra

 - Dijstra算法: -- >贪心
   - 有两个点的集合: A 确定的最短路径的点, B没有确定最短路径的点
   - 每一次从B中找到dis[b]最小的点c,把c加入B
   - 不停这样下去,直到所有点都成为A


```c
void diskstra(){
    int i,j,k;

    /* 计算n次,因为每一次加入一个数进vis */
    for(i=1;i<=n;i++){
        int k,min = INF;

        /* 找到加入点中最小的 */
        for(j=1;j<=n;j++)
            if(!vis[j] && dis[j] < min)
                min = dis[j] ,k=j;
        vis[k]=true;
        /* 用找到的k去更新其它点 */
        for(j=1;j<=n;j++)
            if(G[k][j] != INF && dis[j] >G[k][j]+dis[k]) {//相邻边,且可以更新
                dis[j] = dis[k]+G[k][j];
                pre[j] =k;
            }
    }
}
```

##### (2.1).Dijkstra+heap

```c

```

#### (3).Bellman-ford $$O(ne)$$

原理:任一点经过`n-1`轮更新就得到了这个的到源点的最短路径

 Bellman-Ford算法的思想:**每一次枚举所有的边,用A点更新B点,最多n-1轮更新即成功**


```c

typedef struct edge_t{
    int u;      //边的前一个点
    int v;      //边的后一个点
    int lang;   //边的长度
}edge;


    dis[0]=0;
    for(i=1;i<=num_node-1;i++){
        dis[i]= 0x7fffffff /3;
    }
    
    //进行bellman-ford
    for(i=1;i<=num_node-1;i++)
        for(j=1;j<=num_e;j++){
            int &x = E[j].u,&y=E[j].v,&len = u[j].lang;//这样代码可以写的好看一点
            if(dis[x] > dis[y] + len)
                dis[x] = dis[y] + len;

            if(dis[y] > dis[x] + len)
                dis[y] = dis[x] + len;
        }
    //代码完成
    for(i=1;i<=num_e;i++){
        printf("dis[%d]=%d\n",i,dis[i]);
    }
```
#### (4).SPFA

##### (4.1) 自己维护队列的版本

```c
/*-----------------------------------------------------------------------------
 *  SPFA算法原理：
 *      加入了队列优化的Bellman_ford算法；有些情况下，ford算法会重复运算某些点；
 *      SPFA 当一个点的dis被更新的时候，也许与他相邻的点也需要被更新，所以把这个点加入队列
 *      如果队列为空，那么就结束运算
 *   注意：加入点的进入队列的时候，还需要判断，点是否已经在队列里了，如果已经在，就不需要加入队列了
 *          一个点被拿出队列的时候，也许还可以在被放进去，所以出队时要设为false
 *-----------------------------------------------------------------------------*/

/* 自己维护队列的版本 */
#include <cstdio>
#include <cstring>

#define maxv 1000
#define maxe 1000

const int INF = 0x7fffffff/3;

const int lq =  2*maxv+5; //队列长度  能找都要那么多

int dis[maxv];
int queue[lq+1];
int head=1,tail=0;
bool exist[maxv] = {0};//点是否在队列中
int pre[maxv]={0};      //前趋

//边集数组所用到的数据
int u[maxe],v[maxe],w[maxe];
int first[maxv];
int next[maxe];


int main(){
    freopen("1.in","r",stdin);
    //初始化
    int s,t;//起点,终点
    int n,e;// 多少点，多少边
    int i,j,k;

    scanf("%d%d",&n,&e);
    scanf("%d%d",&s,&t);

    for(i=1;i<=n;i++)
        dis[i] =INF;

    /* s点加入队列 */
    dis[s] =0;
    queue[1] =s;
    head=1,tail=2;
    exist[s] = true;

    /* 边集数组来存图 */
    for(i=1;i<=n;i++)   first[i]=-1; //初始化first
    for(i=1;i<=2*e;i+=2){
        scanf("%d%d%d",&u[i],&v[i],&w[i]);
        v[i+1] = u[i],u[i+1] =v[i],w[i+1]=w[i]; //无向图 一条边存两遍

        next[i] = first[u[i]];
        first[u[i]] = i;

        next[i+1] = first[u[i+1]];
        first[u[i+1]] =i+1;
    }

    int tmp;
    while( head < tail){ //队列非空
        tmp = queue[head];  //取首点
        head = (head % lq) +1;//循环队列
        exist[tmp] = false;     //不在队列中

        for(i=first[tmp];i!=-1;i=next[i])   //更新周围的点
            if(dis[v[i]] > dis[tmp] + w[i]){
                dis[v[i]] = dis[tmp] +w[i];
                pre[v[i]] = tmp;

                /* 被更新的点不在队列中,那就加入队列中 */
                if(!exist[v[i]]){
                    queue[tail]=v[i];
                    tail = (tail % lq) +1;
                    exist[v[i]] = true;
                }
            }
    }

    /* 输出终点dis */
    printf("dis[%d] = %d\n",t,dis[t]);

    /* 输出路径 */
    for(i=t;i!=0;i=pre[i])
        printf("%d ",i);
    return 0;
}
```

##### (4.2) 使用STL的版本

```c
/* 使用stl中的queue版本 */
#include <cstdio>
#include <queue>
using namespace std;

int s,t;// 起点,终点
int n,e;// 点,边

#define maxv 1000
#define maxe 1000

const int INF = 0x7fffffff/3;
queue<int> q;//STL的队列
int dis[maxv];
bool exist[maxv] = {0};//点是否在队列中
int pre[maxv]={0};      //前趋

//边集数组所用到的数据
int u[maxe],v[maxe],w[maxe];
int first[maxv];
int next[maxe];

void spfa_stl(int s){
    int i;
    while(!q.empty()) q.pop();
    /* s点加入队列 */
    dis[s] =0;
    q.push(s);
    exist[s] = true;

    int tmp;
    while(!q.empty()){ //队列非空
        tmp = q.front();    q.pop();// 取队首点
        exist[tmp] = false;     //不在队列中

        for(i=first[tmp];i!=-1;i=next[i])   //更新周围的点
            if(dis[v[i]] > dis[tmp] + w[i]){
                dis[v[i]] = dis[tmp] +w[i];
                pre[v[i]] = tmp;

                /* 被更新的点不在队列中,那就加入队列中 */
                if(!exist[v[i]]){
                    q.push(v[i]);
                    exist[v[i]] = true;
                }
            }
    }
}

int main(){
    freopen("1.in","r",stdin);
    //初始化
    int i,j,k;

    scanf("%d%d",&n,&e);
    scanf("%d%d",&s,&t);

    for(i=1;i<=n;i++)
        dis[i] =INF;


    /* 边集数组来存图 */
    for(i=1;i<=n;i++)   first[i]=-1; //初始化first
    for(i=1;i<=2*e;i+=2){
        scanf("%d%d%d",&u[i],&v[i],&w[i]);
        v[i+1] = u[i],u[i+1] =v[i],w[i+1]=w[i]; //无向图 一条边存两遍

        next[i] = first[u[i]];
        first[u[i]] = i;

        next[i+1] = first[u[i+1]];
        first[u[i+1]] =i+1;
    }

    spfa_stl(s); //调用
    /* 输出终点dis */
    printf("dis[%d] = %d\n",t,dis[t]);

    /* 输出路径 */
    for(i=t;i!=0;i=pre[i])
        printf("%d ",i);
    return 0;
}
```


###  四:图的最小生成树

#### (1).Prim $$O(n^2)$$

##### (1.1).Prim + heap $$O(n \times log(n) )$$

#### (2).Kruskal $$ O(e \times log(e) )$$


### 五.欧拉回路

### 六.哈密顿环


### 七.有向图的强联通分量

#### (1).Gabow


**  Gabow  算法和tarjan 一样,都是通过DFS时,不能返回到最早的点的判断的 **

```c
void gabow(int i){
    int j;
    dfn[i] = ++id;
    s[++st] = i;
    p[++pt] = i;
    printps();
    int e = first[i];
    for(;e!=-1;e=next[e]){
        j=v[e];
        if(dfn[j]== -1)//没有被访问过
            gabow(j);
        else if (color[j] == -1){ // 访问过的点:1, 是这个分量, 另一个分量的
            while(dfn[p[pt]] > dfn[j]) //大于的点 弹出
                pt--;
            printps();
        }
    }
    if(p[pt] == i){
        printf("know anwster:");
        pt--;
        cnt++;
        do {
            j=s[st--];
            color[j] = cnt;
            printf("%d ",j);
        }
        while(j !=i);
        printf("\n");
    }
}
```

#### (2).Kosaraju

Kosaraju 算法可以用来计算强连通分量,并收缩强连通分量

操作步骤

 - 对原图G进行DFS,并将出栈顺序进行反序
 - 对原图G的每一条边时行反序,行到图G~
 - 按照反序,图G~进行DFS,遍历结果生成新的森林W2,W2每棵树上的顶点就构成了有向图的强连通分量

```c
void dfs1(int k){
    vis[k] = 1; // 点k已经访问过
    int i;
    for(i=first[k];i!=-1;i=next[i]){
        if(vis[v[i]] != 1)
            dfs1(v[i]);
    }
    stack[++top] = k; //记录出栈顺序,注意这里top的变化
}

void dfs2(int k){
    vis[k] = cnt; // 点k是哪是强连通分量,也就是DFS染色
    int i;
    for(i=first2[k];i!=-1;i=next2[i]){
        if(vis[v2[i]] == 0)   //没有被访问过
            dfs2(v2[i]);
    }
}

int kosaraju(){
    top = cnt =0;
    memset(vis,0,sizeof(vis));

    int i;
    for(i=1;i<=n;i++){
        if(vis[i]== 0)
            dfs1(i);
    }

    memset(vis,0,sizeof(vis));

    for(i=top;i>=1;i--){
        if(vis[ stack[i] ] == 0){
            cnt++;
            dfs2( stack[i] );
        }
    }

    return cnt;
}
```

#### (3).Tarjan


```c
void tarjan(int x){
    int j;
    dfn[x] = low[x] = ++index;
    instack[x] =true;
    stack[++top] = x;
    int e = first[x];
    for(; e != -1; e = next[e]){
        j = v[e];
        if( !dfn[j] ) // dnf[j] !=0 表示 这个点没有被访问过
        {
            tarjan(j);
            if(low[j] < low[x])
                low[x] = low[j];
        } 
        else if(instack[j] && low[j] < low[x])
            low[x] = low[j];
    }
	if(dfn[x] == low[x])
        {
            cnt++;
            do{
                j=stack[top--];
                instack[j] = false;
                color[j] = cnt;
            }
            while(j !=x);
        }
}

/* 调用 */
    for(i=1;i<=T;i++){ // 遍历所有点
        if(!dfn[i]) // 没有被访问过
            tarjan(i);
    }
```
### 八.拓扑排序

#### (1).方法一:不停输出出度为0的点

#### (2).方法二:DFS

**原理:**想一想对一个无环图(例如tree)进行DFS,一定是先把点x的子树(下面的点)全部输出才会输出自己本身

```c
list --> empty
S   ---> all nodes

for each node in S do
    dfs(node)

dfs ( node )
    if node 没有被访问 do
        设置 node　被访问
        对 node 相临的点 node2
            dfs(node2)
    将node 加入list
```


### 九.二分图最大匹配

```c
#define N 100  //最多点数
/* 定义我们的数据结构 */
int G[N][N];    //用来存图,邻接矩阵
int xN,yN;
int match[N];   //某个点所匹配的点
int vis[N];  //点是不已经访问过,也就是这个点是不是在我们找的增广路中

int cnt =0; //记数
bool dfs(int u){
    int i;
    //所有和u相连的点的
    for(i=1;i<=xN;i++){
        if(G[u][i] !=-1  && vis[i]==0){//sh相连 且没有被加入路中
            vis[i] = 1;     //放入我们找的增广路中
            /*点i有两种可能性:1,不是一个匹配点,也就是没有被加入路中
                              2,是一个匹配点,那就去点i的匹配的的点开始dfs,直到找到一个非匹配点,也就是增广路的结尾
                              返回时,取反
            */
            if(match[i] ==-1 || dfs(match[i])){ //这里建议调试跟一下数据
                match[u] = i;
                match[i] = u;
                return 1;
            }
        }
    }
    return 0;
}

int hungarian(){
    memset(match,-1,sizeof(match));
    int i;
    for(i=1;i<=yN;i++){
        memset(vis,0,sizeof(vis));
        if(match[i] == -1) //从一个没有匹配的点,开始找,那什么是循环yN次呢
            if(dfs(i))
                cnt++;
    }
    return cnt;

}
```

### 次短路

### 次小生成树



## 高级数据结构

### LCA

#### (1).在线算法-倍增思想

```c
int n; // 总共有n个点
int d[100] = {0};//每个点的深度
int f[100];//每个点的父亲
int p[100][100];

void st(){ //预处理
    int i,j;
    memset(p,-1,sizeof(p));
    for(i=1;i<=n;i++) // n个点,dp边界
        p[i][0]=f[i];

    //n个点,理论最深是n,也就是最大有n-1倍祖先,我们算大一点:算成n倍祖先
    // 2^j =n --->j=log(n)/log(2)
    for(j=1;j<=(int)(log(n)/log(2));j++)
        for(i=1;i<=n;i++)
            if(p[i][j-1] != -1)// [1] p[i][j-1] != -1 表明可以用自己去更新别人,为什么要有这个判断?
                p[i][j] = p[p[i][j-1]][j-1];
}

// 求点a,b的最近公共祖先
int LCA(int a,int b){
    /*    先判断是否 d[a] > d[b] ，如果是的话就交换一下(保证 a 的深度小于b，方便下面的操作) */
    int i;
    if(d[a] > d[b])
    {
        int tmp =a;
        a=b;
        b=tmp;
    }

    /* 转为找同层结点  d[a] <= d[b] */
    /* 这种找法 能成功的原因,看折半查找原理*/

    int k = (int)(log(d[b]-1)/log(2));//公式 root 点是b点d[b]-1倍祖先
    for(i=k;i>=0;i--){
        if(d[b]-(1<<i) >=d[a])
            b=p[b][i];
    }
    if(a == b)    //这种情况:b是a的子树
        return a;

    //爬树中,原理:拆半查找原理
    k = (int)(log(d[b]-1)/log(2));

    for(i=k;i>=0;i--)
        if(p[a][i] != p[b][i])
        {
            a=p[a][i];
            b=p[b][i];
        }

    return p[a][0];
}
```

#### (2).离线算法-Tarjan

```c
/*  理解tarjan 就是理解DFS后序输出的过程
 *      tarjanDFS
 *          1. 进入某个点a,  fa[a] =a 自己形成一个集合
 *          2.if hasChild[a] == true tarjanDFS(child[a]) 如果a有孩子,就DFS a的child
 *              2.1 fa[b] =a    a的孩子b 的fa 改为a
 *          3.a的所有子树输出完,正要输出a ,
 *              3.1 find[a,x] or [x,a]
 *              3,2 if visted[x]== false -->lca[a,x] = fa[x]
 *
 * */

/*ver 1.0
代码还不是很完善和精简
*/

#include <cstdio>

struct _q{
    int a;
    int b;


struct node{
    struct node *child[2];
    int val;
    bool vis;
};
node mynode[100];

int f[100]= {0};//并查集用

int find(int x){
    int r =x;
    int tmp;
    while(f[r] != r)//身上找
        r=f[r];
    while(f[x] !=x)
    {
        tmp =f[x];
        f[x] = r;
        x=tmp;
    }
    return r;
}

//把点y所在的集合 加入 点x 所在的集体
void un(int x,int y){ 
    if(find(x) != find(y))
    {
        int root = find(y);
        f[root] = x;
    }
}

void tarjanDFS(node *x){
    int i;
    f[x->val] =x->val;//自己形成一个集合，路过
    for(i=0;i<2;i++){
        if(x->child[i] !=NULL)
            tarjanDFS(x->child[i]);
        //点x的所有子树输出了
        if(x->child[i] !=NULL)
            un(x->val,x->child[i]->val);
    }
    //所有的子树都已经输出了
    x->vis = true;
    for(i=0;i<3;i++){//处理查询
        if(q[i].a == x->val && mynode[q[i].b].vis == true){
            printf("LCA(%d,%d)=%d\n",q[i].a,q[i].b,find(q[i].b));
        }
        if(q[i].b == x->val && mynode[q[i].a].vis == true){
            printf("LCA(%d,%d)=%d\n",q[i].a,q[i].b,find(q[i].a));
        }
    }

}


// struct node mynode[100] 这种方法也对,这种是c语言风格
int n,root;
int main(){
    freopen("1.in","r",stdin);
    int i,j,k,l;
    for(i=0;i<100;i++){ //初始化 并查集
        f[i] = i;
        mynode[i].val = i;
        mynode[i].vis = false;
        mynode[i].child[0] = mynode[i].child[1]=NULL;
    }
    scanf("%d%d",&n,&root);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d%d",&j,&k,&l);
        
        if( k == -1)
            mynode[j].child[0] = NULL;
        else
            mynode[j].child[0] = &mynode[k];
            
        if(l == -1)
            mynode[j].child[1] = NULL;
        else
            mynode[j].child[1] = &mynode[l];
    }
    tarjanDFS(&mynode[root]);
    return 0;
}
```



## STL


## 其它算法

---------------------

### 快速幂
```c
int fast_pow(int a, int b) //求 a^b
{
    int r=1,base =a;
    while(b != 0){
        if(b & 1)  // 假如b = 1011(二进制) 1->1->0->1 base,base^1
            r*=base;
        base*=base;
        b=b>>1;
    }
    return r;
}
```
### 快速幂取模

```c
/* 一句话算法：记住快速幂取模，知道在哪里加入 %n  - r=r*base %n - base =base *base %n */

int pow(int a,int b,int n){
    int r=1,base =a;
    while(b !=0 ){
        if(b & 1)
            r=r * base %n;
        base =base * base;
        b = b >>1;
    }
    return r;
}
```

### HASH 算法

#### (1).BKRDhash

```
unsigned int BKRDhash(char *str ){
    unsigned int seed = 131;
    unsigned int hash = 0;
    while(*str){
        hash = hash*seed +( *str++);
    }

    return hash & 0x7fffffff % 1001 ;
}
```

#### (2).ELFhash

```c
int elfhash(char *key){
    unsigned int hash = 0;
    while(*key){
        hash = (hash<<4) +(*key++);
        unsigned int g = hash & 0xf0000000;
        if(g){
            hash ^= g >>24;
            hash &= ~g;     //高4bit清零
        }

    }

}
```


### 并查集

```c
//初始化
int i;
#define N 1000
int fa[N+1];

for(i=1;i<=N;i++)
    fa[i]=i;


//查找并路径压缩 非递归
int find(int x){
    int t =x;
    while(fa[t] != t) //不停的往上走
        t=fa[t];

    int i = x,j;//路径压缩，再走一便路程，把走过的点都指向根
    while(i != t){
        j= fa[i];
        fa[i] = t; // 把这个点指向根
        i = j;
    }
    
    return t;
}

int path[N]={0};
int find2(int x){
    int count =0;
    while(x != fa[x]){
        path[++count] = x;
        x = fa[x];
    }

    int i;
    for(i=1;i < count;i++){ //这里i < count 是因为 path 记录的第 count 的点一定是指向 root 的,所以可以不用到count
        path[i] = x;
    }
    return x;
}


// 查找 递归法 在面对很深的树的时候 效率很低,且可能会崩溃

int  find3(int x){
    if( x != fa[x]) 
        fa[x] = find(fa[x]);
    else 
        return fa[x];
}


// 合并
int join(int x,int y){ //合并 x, y所在的集合
    int fx = find(x),fy=find(y);
    if( fx != fy)
        fa[fx] = fy;
}


// 合并 优化 ？

```


## 线段树


**单点更新**:hdu1166 敌兵布阵 (

```c
#include <cstdio>

#define lson(rt) (rt<<1)
#define rson(rt) (rt<<1)|1
#define maxn 55555
int ST[maxn<<2];

void pushup(int rt){
    /* 不同的题目有不同的写法 */
    ST[rt] = ST[lson(rt)] +ST[rson(rt)];
}

void build(int l,int r,int rt){
    if(l == r){
        scanf("%d",st[rt]);//想一想,为什么这样可以读取呢?
        return;
    }
    int m =(l+r)>>1;
    build(l,m,lson(rt)); //递归建立左子树
    build(m+1,r,rson(rt));//递归建立右子树
    pushup(rt);//更新当前点
}


void update(int pos,int add,int l,int r,int rt){
    if(l == r){
        ST[rt] += add;
        return;
    }
    int m = (l+r)>>1;
    /* 这样不停的尝试,最的停下的叶子结点一写是poss*/
    if(pos <=m ) update(pos,add,l,m,lson(rt));
    else update(pos,add,m+1,r,rson(rt));
    pushup(rt);
}

int query(int l1,int r1,int l,int r,int rt){
    if(l1 <= l && r <=r1){
        return ST[rt];
    }
    int m =(l+r)>>1;
    int ret = 0;
    if(l1 <=m ) ret+=query(l1,r1,l,m,lson(rt));
    if(r1 >m ) ret+=query(l1,r1,m+1,r,rsson(rt));
    return ret;
}

int main(){
    int T,n;
    scanf("%d",&T);
    int i,j,k;
    for(i=1;i<=T;i++){
        printf("Case %d:\n",i);
        scanf("%d",&n);
        build(1,n,1);
        char op[10];
        while(scanf("%s",op)){
            if(op[0] == 'E') break;
            int a,b;
            scanf("%d%d",&a,&b);
            if(op[0] == 'Q')
                printf("%d\n",query(a,b,1,n,1));
            else if(op[0] == 'S')
                update(a,-b,1,n,1);
            else 
                update(a,b,1,n,1);
        }
    }
}
```

**成段更新**:

```c
*============================================================================
* Title : 线段树 成段替换
* Author: Rainboy
* Time  : 2016-05-27 13:05
* update: 2016-05-27 13:05
* ? Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/

#include <cstdio>
#include <cstring>

const int maxn = 1000;

int st[maxn<<2];
int flag[maxn<<2];

#define lson(rt) (rt<<1)
#define rson(rt) ((rt<<1)|1)

int n,m;

void pushup(int rt){
    st[rt] = st[lson(rt)] + st[rson(rt)];
}

void pushdown(int rt,int m){
    if(flag[rt]){
        flag[lson(rt)] = flag[rson(rt)] = flag[rt];
        st[lson(rt)] = flag[rt]*(m-(m>>1));
        st[rson(rt)] = flag[rt]*(m>>1);
        flag[rt] = 0;
    }
}

void update(int l1,int r1,int c,int l,int r,int rt){
    if(l1 <=l && r<=r1){
        flag[rt] = c; //我们到达一个点
        st[rt] = (r-l+1)*c;
        return ;
    }
    pushdown(rt,(r-l+1));
    int m = (l+r)>>1;
    if( l1 <= m) update(l1,r1,c,l,m,lson(rt));
    if( r1 > m) update(l1,r1,c,m+1,r,rson(rt));
    pushup(rt);

}

int query(int l1,int r1,int l,int r,int rt){
    if(l1<=l && r <= r1){
        return st[rt];
    }
    pushdown(rt,(r-l+1));
    int ret = 0;
    int m = (l+r)>>1;
    if(l1 <= m) ret+= query(l1,r1,l,m,lson(rt));
    if(r1 > m ) ret+= query(l1,r1,m+1,r,rson(rt));
    return ret;
}

void build(int l,int r,int rt){
    if( l==r){
        scanf("%d",&st[rt]);
        return ;
    }
    int m = (l+r)>>1;
    build(l,m,lson(rt));
    build(m+1,r,rson(rt));
    pushup(rt);
}

int main(){
    memset(flag,0,sizeof(flag));
    scanf("%d",&n);
    build(1,n,1);
    scanf("%d",&m);

    int i,j,k;
    char c;
    while(m--){
        scanf("%c",&c); //读两次,滤掉\n
        scanf("%c",&c);
        if( c == 'c' ){
            scanf("%d%d%d",&i,&j,&k);
            update(i,j,k,1,n,1);
        }else {
            scanf("%d%d",&i,&j);
            int ans = query(i,j,1,n,1);
            printf("%d\n",ans);
        }
    }
    return 0;
}

```
### 二进制优化


 一句话算法:**如果余数还能分就分,不然输出余数(0不输出)**
 
用二进制组合任意数,可以少取数,例如:

`14 --> 1,2,4,7-->可以组合成14内的任意数`


```c
    int cnt=0;
    int s=0;
    //写法一:
    while( n >=(1<<cnt)){
        printf("%d ",(1<<cnt));
        n = n-(1<<cnt);
        cnt++;
    }
    if(n>0)
        printf("%d",n);
```

**线段树离散化**

看noipbook上的离散化

**线段树扫描线**

原理:把原图分成的若干矩形

## 常用位运算

### 基本

|  符号  | 操作     |
|:------:|:--------:|
|    &   | 按位与   |
| &#124; | 按位或   |
|    ^   | 按位异或 |
|    ~   | 按位取反 |
|   <<   | 左移     |
|   >>   | 右移     |

### 常用

| 目的                                | 操作                                              |
|-------------------------------------|---------------------------------------------------|
| 读取第k位（元素k是否存在）：        | #define isexist(A,k)  	A>>k&1                    |
| 将第k位设置为1（把k放入集合中）：   | #define add(A,k)        A&#124;=1<<k              |
| 将第k位设置为0（把k从集合中清除）： | #define remove(A,k)  	A&=~(1<<k)                |
| 将第k位取反：                       | #define rev(A,k)  		A^=1<<k                   |
| 将第k1～k2位取反：                  | #define rev2(A,k1,k2)   A^=((1<<(k2-k1+1))-1)<<k2 |
| 枚举所有组合：                      | 从0开始不断地加1。每一个数都代表一个组合。        |
| 集合的交、并、补、差                |                                                   |
| 交集                                | #define cross(A,B)		A&B                       |
| 并集                                | #define union(A,B)		A&#124;B                  |
| 全集                                | #define fill(I,n)		I=(1<<n)-1                |
| 补集                                | #define opp(I,A)			A^I                   |
| 真子集                              | 如果S'是S的真子集，那么有S'＜S。                  |
| 集合中的元素                        |                                                   |
| 去掉最后一位（10011→1001）          | ans = x>>1                                        |
| 在最后加一个0（11101→111010）       | ans = x<<1                                        |
| 在最后加一个1（110→1101）           | ans = (x<<1)+1                                    |
| 取末k位（如k=3时,11101→101）        | ans = x&((1<<k)-1)                                |
| 把末k位变成1（如k=2时，1000→1011）  | ans = x&#124;((1<<k)-1)                           |
| 末k位取反（如k=3时，11010→11101）   | ans = x^((1<<k)-1)                                |
| 把右边连续的1变成0（如1011→1000）   | ans = x&(x+1)                                     |
| 把右边连续的0变成1（如1100→1111）   | ans = x&#124; (x-1)                               |
| 把右起第一个0变成1（如1001→1011）   | ans = x&#124; (x+1)                               |
| 把右起第一个1变成0（如1110→1100）   | ans = x-(x&(-x))                                  |
| 取右边连续的1（如10111→111）        | ans = (x^(x+1))>>1                                |
| 去掉右起第一个1的左边（如11010→10） | ans = x&(-x)                                      |


#### 统计

 - 1.是否恰好只有一个true					`b = !(x&(x-1))&x`
 - 2.判断是否有两个相邻的true				`b = x>>1&x`
 - 3.是否有三个相邻的true					`b = x>>1&x>>2&x`
 - 4.统计true的个数的奇偶性       `x^=x>>1; x^=x>>2; x^=x>>4; x^=x>>8; x^=x>>16;`

>  运算结果的第i位表示在原始数据中从第i位到最高位true数目的奇偶性，
> 有了这个结果，我们就可以很方便地得到任意一段的奇偶性：
> 如果想要得到k1~k2位中true个数的奇偶性，直接计算(x>>k1^x>>(k2+1))&1即可。

**true的数目:**

```c
int count(unsigned int x) 
{ 
	x=(x&0x55555555)+(x>>1&0x55555555); 
	x=(x&0x33333333)+(x>>2&0x33333333); 
	x=(x&0x0F0F0F0F)+(x>>4&0x0F0F0F0F); 
	x=(x&0x00FF00FF)+(x>>8&0x00FF00FF); 
	x=(x&0x0000FFFF)+(x>>16&0x0000FFFF); 
	return x; 
}
```

**反转位的顺序**
```c
unsigned int rev(unsigned int x)
{ 
	x=(x&0x55555555)<<1|(x>>1&0x55555555); 
	x=(x&0x33333333)<<2|(x>>2&0x33333333); 
	x=(x&0x0F0F0F0F)<<4|(x>>4&0x0F0F0F0F); 
	x=(x&0x00FF00FF)<<8|(x>>8&0x00FF00FF); 
	x=(x&0x0000FFFF)<<16|(x>>16&0x0000FFFF); 
	return x; 
}
```

**计算绝对值**

```c
inline int abs(int x)
{
	int y=x>>31; 
	return (x+y)^y; 
}
```

**求较大值**

```c
inline int max(int x,int y)
{
	int m=(x-y)>>31; 
	return y&m|x&~m; 
} 
```
**不使用额外的空间交换两个变量:**

```c
void swap(int& x,int& y) {x^=y;y^=x;x^=y;};
```

**求平均值:**

```c
int ave(int x,int y){return (x&y)+((x^y)>>1);};
```

x与a,b两个变量中的一个相等，现在要切换到另一个：x^=a^b

