## 科协的数字游戏I

### 题目描述

科协里最近很流行数字游戏。某人命名了一种不降数，这种数字必须满足从左到右各位数字成大于等于的关系，如123，446。现在大家决定玩一个游戏，指定一个整数闭区间[a,b]，问这个区间内有多少个不降数。


### 输入格式

题目有多组测试数据。每组只含2个数字a, b (1 <= a, b <= 2^31)。

### 输出格式

每行给出一个测试数据的答案，即[a, b]之间有多少阶梯数。

### 输入样例

```
1 9
1 19
```

### 输出样例

```
9
18
```

## 解析


最简单的想法就是直接搜索,先找一个搜索的规律,设有一个数字$$24$$,从$$0$$开始算,有多少个数满足条件呢?

```
 2       4
+---------+
|        0| 
|        1|
|        2|
|        3|
|0       4|
|        5|
|        6|
|        7|
|        8|
|        9|
+---------+
+---------+
|        1|
|        2|
|        3|
|1       4|
|        5|
|        6|
|        7|
|        8|
|        9|
+---------+
+---------+
|        2|
|2       3|
|        4|
+---------+
```
**为了加深理解,你可以自己找一人数,然后按上面的方法写出所有的可能!**

**规律如下**
 - 前$$i$$位的和$$a$$高位相等,第$$i-1$$位取的范围是$$a[i] \rightarrow a[i-1]$$
 - 前$$i$$位的和$$a$$高位小的时候,第$$i-1$$位取的范围是$$a[i] \rightarrow 9$$


<br>

**状态转移方程:**

```math
f[i][j][0] = f[i-1][k][0],j<=k <9
```

```math
f[i][j][1] = 
\begin{cases}
f[i-1][k][0] & j<=k < a[i-1]  \\ 
+ f[i-1][l][1] & l = a[i-1]
\end{cases}
```
边界:$$f[-1][x][y] = 1$$,表示选到了$$-1$$位为1

 - $$f[i][j][0]$$表示从最高位到$$i+1$$选的数形成的数比原数$$a$$最高位到$$i+1$$形成的数要小,且第$$i$$位选的数为$$j$$情况下的方案数.
 - $$f[i][j][1]$$表示从最高位到$$i+1$$选的数形成的数和原数$$a$$最高位到$$i+1$$形成的数相等,且第$$i$$位选的数为$$j$$情况下的方案数.


显然我们应该用**记忆化搜索**,因为直接递推话不好推

f数组要初始化为-1,表示没有计算过,因为有些可能下你得到值为0,表示不可能,所以不能用0表示没有计算过.

## 代码

```c
/*-------------------------------------------------
*  Author:Rainboy
*  2018-07-07 10:46
*-------------------------------------------------*/

#include <cstdio>
#include <cstring>

int n1,n2;
char a[100];

int f[40][40][2];

typedef long long ll;


// pos表示第几位,pre 表示pos+1位选的什么数,done 表示最高位到pos+1选的数是不是比原数小,1表示相等
int dfs(int pos,int pre,bool done){
    if( pos == -1) return 1; // 边界

    // 
    if(f[pos+1][pre][done] != -1)
        return f[pos+1][pre][done];

    int end = done ? a[pos] : 9;
    int i,res = 0;
    for(i=pre;i<=end;i++){
        // 前面相等 且 自己为a[pos],才相等
        bool dengyu  = done && i == end; 
        res += dfs(pos-1,i,dengyu);
    }
    f[pos+1][pre][done] = res;

    return res;
}

int solve(int num){
    memset(f,-1,sizeof(f)); //初始化为-1

    int idx = 0;

    while( num >0){
        a[idx++] = num % 10;
        num /= 10;
    }

    return dfs(idx-1,0,1);

}

int main(){
    
    while( scanf("%d %d",&n1,&n2) !=EOF){
        int ans = solve(n2) -solve(n1-1);
        printf("%d\n",ans);
    }
    return 0;
}
```
