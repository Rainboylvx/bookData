# Little Kings

题目地址:[sgu223](https://vjudge.net/problem/SGU-223)

## 题目描述

在$$n \times n,1<=n<=10$$的棋盘上放$$k,1<=k<=n \times n$$个国王(可攻击相邻的8个格子),求使它们无法互相攻击的方案总数.

## 输入格式

输入有多组数据,每组只有一行为两个整数n和k

## 输出格式
每组数据输出一行为方案总数,若不能放置则输出0

## 输入样例

```
3 2
4 4
```

## 输出样例

```
16
152
```


## 解析

能搜索吗?好像很难.

你会发现第$$i+1$$行的放置状态只有第$$i$$行的状态有关.

f[i][j][k] 前i行,有k个国王且第i的状态为state[j]的条件下的方案数.

那么,状态转移方程为:



```math

f[i][j][k] \leftarrow f[i-1][j_1][k_1]

k_1+num(a[j]) = k

f[i][j][k] = max { f[i][j][k], f[i-1][j_1][k_1]+ \sum state[j]}

```
$$a(j_1) $$与$$a(j)$$不冲突

边界:$$f[0][0][0] = 0$$表示前0行,状态为a[0],且放0个国王的方案数为0


为了操作简单,我们可以先枚举一行的所有可能状态.`同一行相邻的国王的距离必须 大于 1`


枚举一行可能性的代码:

```c
int a[20] = {0};
int state[500];
int cnt = 0;

int arr2bin(){
    int i;
    int s = 0;
    for(i=n;i>=1;i--){
        if( a[i] )
            s = s |(1 <<(i-1));
    }
    return s;
}

void dfs(int dep){
    //边界
    if(dep == n+1){
        int t = arr2bin();
        state[cnt] = t;
        cnt++;
        return;
    }

    a[dep] = 0;  //不放
    
    dfs(dep+1);

    //放
    if(a[dep-1] == 0) // 前1个格子没有
    {
        a[dep] = 1;
        dfs(dep+1);
        a[dep] = 0;
    }
}
```


## 代码
