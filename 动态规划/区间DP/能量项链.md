# 能量项链

## 解析

(2,3) (3,5) (5,10) (10,2)

1:(2,3) ---> (3,5) (5,10) (10,2)  f(2,4)+f(1,1)+2*3*2
2:(2,3) (3,5) ---->(5,10) (10,2)  f(1,2)+f(3,4)+2*5*2
3:(2,3) (3,5) (5,10)------(10,2)  f(1,3)+f(4,4)+2*10*2

f(i,j)表示第i个珠子到第j个珠子合并成一个珠子后,所能得到最大能量

s[i] 表示第i个珠子的开头的数字
t[i] 表示第i个珠子的结尾的数字
s[1] = 2 ,t[1] =3

f(i,j) = max{f(i,k)+f(k+1,j) + s[i] * t[k] * t[j]} i<=k < j

边界: f(i,i) = 0

手动推导一下:
  1		2	   3	 4
(2,3) (3,5) (5,10) (10,2)

//------ 求出长度为2的合并
f(1,2) = f(1,1)+f(2,2)+2*3*5 = 30
f(2,3) = 3*5*10 = 150
f(3,4) = 5*10*2 = 100

//------ 求出长度为3的合并
f(1,3) = 210
	1: f(1,1)+f(2,3)+2*3*10 =0+150+60 = 210    <====
	2: f(1,2)+f(3,3)+2*5*10 = 30+0+100 = 130

f(2,4) = 210
	1: f(2,2)+f(3,4)+3*5*2 = 0+100+30 = 130
	2: f(2,3)+f(4,4)+3*10*2= 150+0+60 = 210  <====
	
//------ 求出长度为4的合并
f(1,4) = 250
	1: f(1,1)+f(2,4)+2*3*2 = 210+12
	2: f(1,2)+f(3,4)+2*5*2 = 30+100+20 
	3: f(1,3)+f(4,4)+2*10*2 = 210+0+40

	
拆环成链:
  1		2	   3	 4
(2,3) (3,5) (5,10) (10,2) ==>


  1		2	   3	 4     	5	  6		7
(2,3) (3,5) (5,10) (10,2) (2,3) (3,5) (5,10)


最终答案就是max{f(1,4),f(2,5),f(3,6),f(4,7)}



状态转移方程
```math
f[i][j] = max\{f[i][k]+f[k+1][j]+ a[i]*b[k]*b[j]\} i<=k<j
```

边界:

```math
f[i][i] = 0
```

## 代码

```c
#include <cstdio>

#define N 200
int n;
int a[N],b[N]; //开头,结尾

int f[N][N] = {0};

//第i 到 第j
int mul(int i,int k,int j){
    return a[i]*b[k]*b[j];
}

//2 3 5 10
//2 3 5 10 2 3 5

int main(){
    scanf("%d",&n);
    int i,j,k;
    for (i=1;i<=n;i++){
        scanf("%d",&a[i]);
        a[i+n] =a[i];
    }


    int t = n;
    n = 2*n-1;

    for (i=1;i<n;i++) b[i] = a[i+1];
    b[n] = a[t];

    for(i=2;i<=t;i++) //长度
        for(j=1;j<=n-i+1;j++){
            for(k=j;k<j+i-1;k++){
                int m  = f[j][k]+f[k+1][j+i-1]+mul(j,k,j+i-1);
                if( f[j][j+i-1] < m)
                     f[j][j+i-1] = m;
            }
        }
    int max = -1;
    for (i=1;i<=t;i++){
        if( max <  f[i][i+t-1])
            max =  f[i][i+t-1];
    }
    printf("%d\n",max);
    return 0;
}
```
