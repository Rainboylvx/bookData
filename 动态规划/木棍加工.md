
## 题目

### 【问题描述】

一堆木头棍子共有n根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：
第一根棍子的准备时间为1分钟；
如果刚处理完长度为L，宽度为W的棍子，那么如果下一个棍子长度为Li，宽度为Wi，并且满足L>＝Li，W>＝Wi，这个棍子就不需要准备时间，否则需要1分钟的准备时间；
计算处理完n根棍子所需要的最短准备时间。比如，你有5根棍子，长度和宽度分别为(4, 9)，(5, 2)，(2, 1)，(3, 5)，(1, 4)，最短准备时间为2（按(4, 9)、(3, 5)、(1, 4)、(5, 2)、(2, 1)的次序进行加工）。

### 【输入】

第一行是一个整数n(n<＝5000)，第2行是2n个整数，分别是L1，W1，L2，w2，…，Ln，Wn。L和W的值均不超过10000，相邻两数之间用空格分开。

### 【输出】
仅一行，一个整数，所需要的最短准备时间。

### 【样例】

```
5 
4 9 5 2 2 1 3 5 1 4
```

```
2
```

## 解析

引用:http://blog.csdn.net/acdreamers/article/details/7626671 

题意：一种导弹拦截系统的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉
到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。输入导弹依次飞来的高
度，计算这套系统最多能拦截多少导弹，**如果要拦截所有导弹最少要配备多少套这种导弹拦截系统？**

第一问很简单，就是求最长不上升子序列

我们把第二问的问题抽象出来，那就是：把一个数列划分成最少的最长不升子序列，这里我们要介绍一个很优美的定理。
 
 - Dilworth定理：对于一个偏序集，最少链划分等于最长反链长度。
 - Dilworth定理的对偶定理：对于一个偏序集，其最少反链划分数等于其最长链的长度。

也就是说把一个数列划分成最少的**最长不升子序列的数目**就等于这个**数列的最长上升子序列的长度**。

例如数列:

```
4 1 5 9 2
```

最长上升子序列的长度:3,`1 5 9`

那么它划分成的最少的最长不升子序为:

```
4 1 2
5
9
```

面对这一个题目,我先按一个元素排序,得到:

```
1 2 3 4 5
4 1 5 9 2
```
我们明显要求`4 1 5 9 2`的划分最少的**最长不下降的子序列**的数目,也就是求它的**最长下降子序的长度**,`4 1`,明显长度是2

关于定理的正确性证明,自己看原网址

## 代码

```c
#include <cstdio>

//木棍
struct __g {
    int x,y;
};

__g g[5010];
int f[5010] = {0};
int n;

void bubble_sort(__g a[],int n){
    int i,j;
    __g tmp;
    for(i=1;i<=n-1;i++) //n个数,要进行n-1趟排序
        for(j=1;j<=n-i;j++){//第i趟排序的最后一个下标:n-i
            if(a[j].x > a[j+1].x){
                tmp =a[j];
                a[j] =a[j+1];
                a[j+1]=tmp;
            }
        }
}

int main(){
    scanf("%d",&n);
    int i,j;
    for (i=1;i<=n;i++){
        scanf("%d%d",&g[i].x,&g[i].y);
    }
    bubble_sort(g,n);

    //求最长下降子序列长度
    f[1] = 1;
    int max = 1;
    for(i=2;i<=n;i++)
        for(j=1;j<i;j++){
            if(g[i].y < g[j].y){
                if(f[i] < f[j]+1){
                    f[i] = f[j]+1;
                    if( max < f[i])
                        max = f[i];
                }
            }
        }
    printf("%d",max);
    return 0;
}
```
