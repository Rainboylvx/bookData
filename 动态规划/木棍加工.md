
## 题目

题目地址：https://www.luogu.org/problemnew/show/P1233

### 【问题描述】

一堆木头棍子共有n根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：
第一根棍子的准备时间为1分钟；
如果刚处理完长度为L，宽度为W的棍子，那么如果下一个棍子长度为Li，宽度为Wi，并且满足L>＝Li，W>＝Wi，这个棍子就不需要准备时间，否则需要1分钟的准备时间；
计算处理完n根棍子所需要的最短准备时间。比如，你有5根棍子，长度和宽度分别为(4, 9)，(5, 2)，(2, 1)，(3, 5)，(1, 4)，最短准备时间为2（按(4, 9)、(3, 5)、(1, 4)、(5, 2)、(2, 1)的次序进行加工）。

### 【输入】

第一行是一个整数n(n<＝5000)，第2行是2n个整数，分别是L1，W1，L2，w2，…，Ln，Wn。L和W的值均不超过10000，相邻两数之间用空格分开。

### 【输出】
仅一行，一个整数，所需要的最短准备时间。

### 【样例】

```
5 
4 9 5 2 2 1 3 5 1 4
```

```
2
```

## 解析


例如数列:

```
4 1 5 9 2
```

最长上升子序列的长度:3,`1 5 9`

那么它划分成的最少的最长不升子序为:

```
4 1 2
5
9
```

面对这一个题目,我先按一个元素排序,得到:

```
1 2 3 4 5
4 1 5 9 2
```
我们明显要求`4 1 5 9 2`的划分最少的**最长不下降的子序列**的数目,也就是求它的**最长下降子序的长度**,`4 1`,明显长度是2

关于定理的正确性证明,自己看原网址

## 代码

```c
#include <cstdio>

//木棍
struct __g {
    int x,y;
};

__g g[5010];
int f[5010] = {0};
int n;

void bubble_sort(__g a[],int n){
    int i,j;
    __g tmp;
    for(i=1;i<=n-1;i++) //n个数,要进行n-1趟排序
        for(j=1;j<=n-i;j++){//第i趟排序的最后一个下标:n-i
            if(a[j].x > a[j+1].x){
                tmp =a[j];
                a[j] =a[j+1];
                a[j+1]=tmp;
            }
        }
}

int main(){
    scanf("%d",&n);
    int i,j;
    for (i=1;i<=n;i++){
        scanf("%d%d",&g[i].x,&g[i].y);
    }
    bubble_sort(g,n);

    //求最长下降子序列长度
    f[1] = 1;
    int max = 1;
    for(i=2;i<=n;i++)
        for(j=1;j<i;j++){
            if(g[i].y < g[j].y){
                if(f[i] < f[j]+1){
                    f[i] = f[j]+1;
                    if( max < f[i])
                        max = f[i];
                }
            }
        }
    printf("%d",max);
    return 0;
}
```
