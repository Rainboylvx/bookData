# 01背包

## 普通01背包

### [问题描述]

给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?

### 输入格式/样例

格式:第一行有两个数n,C,表示有n个物品,背包的容量为C.接下来n行,每一行两个数w,v,表示物品的重量和价值.

```
5 10
2 6
2 3
6 5
5 4
4 6
```
### 问题分析

对于一种物品，要么装入背包，要么不装。所以对于一种物品的装入状态可以取0和1.我们设物品i的装入状态为xi,xi∈(0,1)，此问题称为0-1背包问题

我们设$$f(i,j)$$表示前i个物品在容量为j的条件得到的最大价值.

```math
f(i,j)=\left\{\begin{matrix}
 0& i==0 \\
 max\{f(i-1,j),f(i-1,j-w[i])+v[i]\}& j>=w[i]
\end{matrix}\right.
```

$$f(0,j)$$,前0个物品得到的价值为0,也是边界.
其中$$f(i-1,j)$$表示前i-1个物品在容量为j的条件得到的最大价值,也就是不选第i个物品.
其中$$f(i-1,j-w[i])+v[i]$$表示前i个物品中一定选第i个物品的条件下得到的最大价值.
$$f(5,10)$$就是我们最后要求的答案.

### 代码

注意我们这里的边界是f[0][j].

```c
#include <cstdio>

//手动初始化数据
int n=5,c=10;
int w[] = {0,2,2,6,5,4};
int v[] = {0,6,3,5,4,6};

//清空置零,同时前0个物品,边界,f[0][j]=0
int f[6][11]={0};

void Knapsack01(){
    int i,j;
    for(i=1;i<=5;i++)//前i个物品
        for(j=1;j<=10;j++){
            if( j-w[i] >=0){ // 在容量j的条件下能放进去
                if(f[i-1][j] > f[i-1][j-w[i]]+v[i])
                    f[i][j] = f[i-1][j];
                else
                    f[i][j] = f[i-1][j-w[i]]+v[i];
            }
            else { // 在容量j的条件下第i个物品放不下
                f[i][j] = f[i-1][j];
            }
        }
}
int main(){
    Knapsack01();
    printf("%d",f[5][10]);//输出答案
    return 0;
}
```

代码演示: http://dsa.rainboy.cc/#/01Knapsack

## 01背包一维写法

看完上面的代码演示和仔细考虑过代码和状态转移方程后,你会发现一些重要的规律:

 - 每一行的状态都需要上一行(前一层)的状态推导出来
 - 第i行的第j个状态f[i][j]一定是由f[i-1][j]和f[i-1][k]得到的,且k一定小于j

根据上面的规律,我们可以这样做:

 - 定义一个一维的数组f[j]表示状态:f[j]表示前i个物品在容量为j的条件下的最大价值
 - 我们可以很容易的得到第一个物品的所有的状态
 - 在处理前2个物品的状态的时候从f[10]到f[0]倒过来处理

上面的操作可以把01背包的二维状态压缩到1维,节省了空间和代码复杂度.

![一维](./一维.png)


### 伪代码

```c
for i=1->N //前i个物品
    for j=C->w[i] //容量从大到小
        f[j] = max(f[j],f[j-w[i]]+v[i])
```

### 代码

```c
#include <cstdio>

//手动初始化数据
int n=5,c=10;
int w[] = {0,2,2,6,5,4};
int v[] = {0,6,3,5,4,6};

//清空置零,同时前0个物品,边界
int f[11]={0};

void Knapsack01(){
    int i,j;
    for(i=1;i<=n;i++)//前i个物品
        for(j=c;j>=w[i];j--){
            if(f[j] < f[j-w[i]]+v[i])
                f[j] = f[j-w[i]]+v[i];
        }
}
int main(){
    Knapsack01();
    printf("%d",f[10]);//输出答案
    return 0;
}
```

代码演示: http://dsa.rainboy.cc/#/01Knapsack1


## 恰好装满


有的时候题目会问我们**恰好装满背包**时最优解.

这种时候,在初始化的时候除了$$F[0]$$为0,其它$$F[1..V]$$设为$$-\infty$$,这样就可以保证最终得到的$$F[V]$$ 是一种恰好装满背包的最优解。


这是为什么呢？可以这样理解：初始化的$$F$$数组事实上就是在没有任何物品可以放 入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为$$-\infty$$了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为0了。

这个小技巧完全可以推广到其它类型的背包问题，后面不再对进行状态转移之前的初始化进行讲解。


图解:

![2](./恰好装满.png)


有很多表示那种能否到达,(前i个物品选j个能否达到某个重量),这种情况下可以抽象成01背包的恰好装满,比如`砝码称重(cojs)`,`猫狗大战(vijos)`等

**题目地址:**[luogu P2347 砝码称重](https://www.luogu.org/problemnew/show/P2347)

状态转移方程:设$$f[i]$$表达重量$$i$$能不能达到.

```math
f[i]=\left\{\begin{matrix}
 1&i==0 \\
 f[i-w[i]]& i-w[i]>0
\end{matrix}\right.
```

```c
#include <cstdio>
#include <cstring>

int a[] = {0,1,2,3,5,10,20};
int num[10] = {0};
int f[1010] = {0};

int main(){
    int i,j,k;
    for(i=1;i<=6;i++)
        scanf("%d",&num[i]);

    f[0] = 1; //边界,前0个砝码,容量为0的条件是是可以达到的
    for(i=1;i<=6;i++)
        for(j=1;j<=num[i];j++)
            for(k=1000;k>=a[i];k--)
                if(f[k] == 0 && f[k-a[i]] == 1)
                    f[k] = 1;
    int cnt = 0;
    for(i=1;i<=1000;i++)
        if( f[i] == 1)
            cnt++;
    printf("Total=%d",cnt);
    return 0;
}
```

## 01背包记录路径.

用二维数组来记录，path[ m ] [ n ] 。其中m表示物品（m<=物品数），n表示背包状态（n<=背包容量）。

比如 path [ i ] [ j ] 表示物品 i 放在了状态 j 的背包中。 前提条件：path数组全部为0，

代码实现记录路径：

```c
		for(int i=0;i<n;i++)
			for(int j=V;j>=v[i];j--)
				if(f[j]<f[j-v[i]]+w[i])
				{
					f[j]=f[j-v[i]]+w[i];
					path[i][j]=1; //把装进去的物品标记一下
				}
```

路径读取代码：

```c
		int i=n-1,j=V; //V：背包容量。n个物品 
		while(i>=0&&j>=0)
		{
			if(path[i][j])//物品i在j里 
			{
				printf("%d ",i);//把物品i的编号输出 
				j-=v[i];  //读完了物品i，找下一个背包状态 
			}
			i--; 
		}
```

## 总结


01背包问题是最基本的问题,它包含了背包问题中设计状态,方程的最基本思想.另外,别的类型的背包问题往往转换成01背包问题求解.故一定要仔细体会上面基本思路的得出方法.状态转移方程的意义,以及空间复杂度怎么被优化.

## 作业

 - 采药 来源：NOIP2005（普及组） 第三题 (pcs有题解)
 - luogu P2925 [USACO08DEC]干草出售 标准01背包
 - 砝码称重 恰好装满
 - 积木城堡 来源：vijos P1059
 - 开心的金明
 - 金明的预算方案 来源：NOIP2006 第二题
 - Money Systems luogu p1474 恰好装满
 - 猫狗大战 恰好装满
 - 新年趣事之打牌 来源： vijos P1071
