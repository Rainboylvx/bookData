---
_id: "61e7173887"
title: 欧拉筛
date: 2019-12-23 16:50
update: 2019-12-23 16:50
author: Rainboy
---

## 原理

显然我们已经会了简单的埃式筛,但它的时间复杂度是$O(nloglogn)$,下面说一下$O(n)$的欧拉筛.

**核心在于如何在筛数的过程中,每个合数只筛一次**.这里用到了一个重要的定理:任何一个合数都可以拆成若干个素因数的乘积.

例如:$77 = 7 \times 11$

任何一个合数都可以拆成一个最小素因数和另一个数的乘积.显然不存在任何两个数的这种拆法相同.

$$
a = b \times k
$$

显然可以写出如下的代码:
```c
int notp[maxn] = 0;
int prime[maxn] = 0;
for( i = 2; i<=maxn;i++){
    //如果这个数没有被筛掉,prime[0]素数的个数
    if( !notp[i] ) prime[++prime[0]] = i;
    for(j=1;j<=prime[0] && prime[j]*i <= maxn;i++){
        notp[prime[j]*i] = 1;
    }
}
```

然后加上一句优化,变成完全体,保证每个 

```c
int notp[maxn] = 0;
int prime[maxn] = 0;
for( i = 2; i<=maxn;i++){
    //如果这个数没有被筛掉,prime[0]素数的个数
    if( !notp[i] ) prime[++prime[0]] = i;
    for(j=1;j<=prime[0] && prime[j]*i <= maxn;i++){
        notp[prime[j]*i] = 1;
        if( i % prime[j] == 0) break;
    }
}
```

如何理解这句话呢?`if( i % prime[j] == 0) break;`

如果$i \mod\ prime[j] == 0$,那么$i ==prime[i] * k$可以写成这种形式,那么$prime[j+1]*i  == prime[i] * k*prime[j+1]$
根据上面的**保证每个合数被拆一次**,那么显然$prime[j+1]*i$这个数,不应该在这里被筛掉,应该在$i == k*prime[j+1]$的时候被筛掉.

## 模板

<!-- template start -->
时间复杂度:$O(n)$

```c
/* 欧拉筛,记录小于等于maxn的素数 */
void getPrime(){
    int i,j;
    for(i=2;i<=maxn;++i){
        //没有被筛掉,是素数
        if( !notp[i]) notp[ ++notp[0]] = i;
        for(j=1;j<=notp[0] && notp[j] *i <=maxn;++j){
            notp[i* notp[j]] = 1;
            if( i % notp[j] == 0) break;
        }
    }
}
```
<!-- template end -->


## 模板题目

 - [luogu P3912 素数个数](https://www.luogu.com.cn/problem/P3912)

