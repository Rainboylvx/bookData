---
_id: "db1e3a5108"
title: dfs序经典问题
date: 2020-10-14 15:52
update: 2020-10-14 15:52
author: Rainboy
---
<!-- template start -->
## 1、单点修改，子树查询 (直接维护)

直接用数据结构维护 DFS 序即可。

## 2、树链修改，单点查询 (贡献)

考虑将树链分割。若修改(u,v)+1则等价于修改(1,u)+1,(1,v)+1,(1,LCA)−1,(1,fa(LCA)−1)
那么只用处理根到某个点的树链修改。
修改即修改dfn(u)+1,dfn(v)+1,dfn(LCA)−1,dfn(fa(LCA))−1
考虑一个查询一个点y，由贡献来看，只有y子树的点会对(1,y)产生贡献。所以直接查询y子树即可。

## 3、树链修改，子树查询 (贡献)

考虑将树链分割。若修改(u,v)+1​则等价于修改(1,u)+1,(1,v)+1,(1,LCA)−1,(1,fa(LCA)−1)​
那么只用处理根到某个点的树链修改。
修改即修改dfn(u)+1,dfn(v)+1,dfn(LCA)−1,dfn(fa(LCA))−1
考虑一个查询一个子树y，由贡献来看，只有y子树的点会对(1,y)产生贡献。
这里和上面不一样了，设dep(x)为x深度，v(x)为数据结构上x的权，则∀x∈subtree(y)，他的贡献为(dep(x)−dep(y))×v(x)
转化，得dep(x)×v(x)−dep(y)×v(x)
写成和的形式，则∑x∈subtree(y)dep(x)×v(x)−dep(y)×v(x)
即∑x∈subtree(y)dep(x)×v(x)−dep(y)∑x∈subtree(y)v(x)
用数据结构维护dep(x)×v(x),v(x)即可求解。

## 4、单点修改，树链查询 (差分序列)

考虑将树链分割。若查询(u,v)则等价于查询(1,u)+(1,v)−(1,LCA)−(1,fa(LCA)−1)
那么只用处理根到某个点的树链查询。
对于修改y，维护差分序列，那就直接差分点y的子树即可，答案即为∑i=1dfn(y)val(i)。

## 5、子树修改，单点查询 (贡献+差分序列 / 直接维护)

对于询问y，只有修改x是y的祖先x才会贡献y。
所以单点修改x，查询(1,y)的权和，转化为问题 4
或直接用数据结构维护 DFS 序即可。

## 6、子树修改，子树查询 (直接维护)

直接用数据结构维护 DFS 序即可。

## 7、子树修改，树链查询 (贡献+差分序列)

和 4 类似的问题。这里就是要处理一下深度，用类似 2 的方法处理即可。
例题：Bzoj 4034

## 总结：

DFS序的问题主要有几种处理方法：

1. 直接维护 (维护原数组)
2. 贡献法
3. 维护差分序列 (询问前缀和)

本质上还是要将询问变为询问子树(维护原数组)，询问前缀和(维护差分序列)

路径交 / 并问题
路径并：Bzoj 3991，Loj 10132(多条路径并)
路径交：CF 832D(两条路径交，并且有一个端点重合)，Hdu 6110(多条路径交)

判两条路径有没有交，只要一条链的lca在另一条链上就一定有交；取两条路径的交，把两条路径的端点两两求出四对lca，最深那两个就是路径交。
<!-- template end -->

## 参考

 - [倍增LCA / DFS序 学习笔记](https://blog.flyinthesky.win/szLCA/)
