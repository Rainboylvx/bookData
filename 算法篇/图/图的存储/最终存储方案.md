---
_id: "6073405308"
title: 图的存储方案
date: 2020-10-19 11:13
update: 2020-10-19 11:13
author: Rainboy
cover: 
---

## 代码封装

我们把代码封装成一个结构体
<!-- template start -->
```c
const int maxn = 1e6+5;
const int maxe = 1e6+5;

struct xlx {
    typedef struct {int u,v,w,next;} edge;
    edge e[maxe];
    int h[maxn],edge_cnt=0;
    xlx(){
        edge_cnt=0;
        memset(h,-1,sizeof(h));
    }
    void add(int u,int v,int w=0){
        e[edge_cnt] = {u,v,w,h[u]};
        h[u] = edge_cnt++;
    }
    void add2(int u,int v,int w=0){
        add(u,v,w);
        add(v,u,w);
    }
    edge& operator[](int i){
        return e[i];
    }
};
```
<!-- template end -->


## 其它封装


**代码1**：使用vector代替数组


```c
const int maxn = 1e6+5;
int n,m;

struct xlx {
    typedef struct {int u,v,w,next;} edge;
    vector<edge> e; //使用vector代替数组
    vector<int> h;
    xlx(){
        h = vector<int> (maxn,-1);
    }
    void add(int u,int v,int w=0){
        e.push_back({u,v,w,h[u]});
        h[u] = e.size()-1;
    }
    void add2(int u,int v,int w=0){
        add(u,v,w);
        add(v,u,w);
    }
    edge& operator[](int i){
        return e[i];
    }
};
```


**代码2**：vector模拟链表

```c
const int maxn = 1e6+5;
int n,m;

struct xlx {
    typedef struct {int v,w;} edge;
    vector<edge> e[maxn];
    void add(int u,int v,int w=0){
        e[u].push_back({v,w});
    }
    void add2(int u,int v,int w=0){
        add(u,v,w);
        add(v,u,w);
    }
    vector<edge>& operator[](int i){
        return e[i];
    }
};
```

优点：码量最少


## 三中代码的比较

在笔者的电脑上，在面对`10000`个点，`1000000`条边的情况下，三种方案运行时间如下

| 方案     | 时间  |
|----------|-------|
| 最终方案 | 185ms |
| 代码1    | 281ms |
| 代码2    | 443ms |


[测试代码与数据下载](./res/data.zip)
