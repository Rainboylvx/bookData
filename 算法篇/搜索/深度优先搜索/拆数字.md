# 拆数字

### [题目描述]

有一种数字拆分方式如下,可以看到6有11种拆分方式,求给定的数字n的拆分方式的数量(1000>=n>=10)

### [输入样列]

```
6
```

### [输出样列]

```
11
```


### [输出解释]

```
6
5+1
4+2 4+1+1
3+3 3+2+1 3+1+1+1
2+2+2 2+2+1+1 2+1+1+1+1
1+1+1+1+1+1
```

## 思路1

$$6$$的拆法也可以这样写

```
6+0
5+1+0
4+2+0
4+1+1+0
3+3+0
3+2+1+0
3+1+1+1+0
2+2+2+0
2+2+1+1+0
2+1+1+1+1+0
1+1+1+1+1+0
```

对于数字$$n$$,你会发现如下的规律:

 - 如果剩余的数为$$0$$,就停止
 - 后面的数不能比前面的数大
 - 开头的数不停的减小,直到1
 - 剩余的数的拆法是一样的(递归关系)


**代码:**

todo!!



## 思路2

**没有想法?**

先尝试写一下其它数字的分法:

```
5
4+1
3+2 3+1+1
2+2+1 2+1+1+1
1+1+1+1+1
```

```
7
6+1
5+2 5+1+1
4+3 4+2+1 4+1+1+1
3+3+1 3+2+2 3+2+1+1 3+1+1+1+1
2+2+2+1 2+2+1+1+1 2+1+1+1+1+1
1+1+1+1+1+1+1
```

重点: 看这一行

```
3+3+1 3+2+2 3+2+1+1 3+1+1+1+1
```

如果把开头的3去掉,那么:

```
3+1
2+2 2+1+1
1+1+1+1
```

这不就表示的是$$4$$不超过$$3$$的拆法吗?明显发现这种拆分是一种递归的关系.


如果我们要把数字`2`拆分,

```
2  第一行,自己本身,对应6
1+1 开头取一个比2少1的数字,剩下的数字再按这种方式拆分
```

我们把这种拆分方式为`f`,如果有一个数字`n`,按方式`f`拆分:

```
n   第一行n本身
(n-1)+1 第二行开头取(n-1),剩下1按f拆分,
(n-2)+2 (n-2)+1+1 第二行开头取(n-2),剩下2按f拆分,

...
```


我们设$$f(n,m)$$表示数字$$n$$按上面的方法拆分,最大数字不超过$$m$$的方案数,如$$f(4,3)$$,如下

```
3+1
2+2 2+1+1
1+1+1+1
```

显然$$f(n,1)=1$$,$$f(n,n) = 1+f(n,n-1)$$


**下面写出第一行的拆法数**

```
7                             1
6+1                           f(7-6,6)=>f(1,6) => f(1,1)
5+2 5+1+1                     f(7-5,5)=>f(2,5) => f(2,2)
4+3 4+2+1 4+1+1+1             f(7-4,4)=>f(3,4) => f(3,3)
3+3+1 3+2+2 3+2+1+1 3+1+1+1+1 f(7-3,3)=>f(4,3) => f(4,3)
2+2+2+1 2+2+1+1+1 2+1+1+1+1+1 f(7-2,2)=>f(5,2) => f(5,2)
1+1+1+1+1+1+1                 f(7-1,1)=>f(6,1) => f(6,1)
```

你会发现$$f(n,m) = f(n,n), n < m$$

$$f(n,m)$$表示$$n$$不超过$$m$$的拆法,它包括两种可能性:

 1. 包括$$m$$,这个时候把$$m$$去除,剩余的数为$$n-m$$,对$$n-m$$进行拆分,但不能超过$$m$$,那就是$$f(n-m,m)$$
 2. 不包括$$m$$:$$f(n,m-1)$$


**状态转移方程如下:**

 - $$f(n,n) = 1+f(n,n-1)$$
 - $$f(n,m) = f(n-m,m) +f(n,m-1)$$,$$ m-1>=1$$
 - $$f(n,m) = f(n,n)$$,$$n < m $$
 - 边界:$$f(n,1) =1$$

**代码**

```c
#include <cstdio>

int n;

int f(int n,int m){
    if( m == 1) // 边界,写在最前面
        return 1;

    if( n == m)
        return 1+ f(n,m-1);

    if( m > n )
        return f(n,n);
    
    return f(n-m,m) + f(n,m-1);
}

int main(){
    scanf("%d",&n);
    int ans  = f(n,n);

    printf("%d",ans);
    return 0;
}
```

### 记忆化搜索

思路2看起来比思路1复杂,但有一个好处就是可以用**记忆化搜索**,加快代码运行速度!

我们设一个二维$$f[n][m]$$来存放数字$$n$$不超过$$m$$的拆分方案.如果$$f[n][m]!=0$$表示它已经计算过了,不用重复计算.

**代码**
```c
#include <cstdio>

int n;

int f[100][100] = {0};

int dfs(int n,int m){

    if( f[n][m] != 0) // 记忆化搜索
        return f[n][m];

    if( m == 1) // 边界,写在最前面
        return 1;

    if( n == m)
        return 1+ dfs(n,m-1);

    if( m > n )
        return dfs(n,n);
    
    int ans = dfs(n-m,m) + dfs(n,m-1);
    f[n][m] = ans;
    return ans;
}

int main(){
    scanf("%d",&n);
    int ans  = dfs(n,n);

    printf("%d",ans);
    return 0;
}
```
