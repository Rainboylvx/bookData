---
title: 离散化
date: 2019-10-14 09:42
update: 2019-10-14 09:42
author: Rainboy
---

@[toc]

## 题目

[roj地址](<%- USER.ROJ_P%>1681)

### 题目描述

你有一组数,这些数有可能重复,你的任务是给每个数一个编号,最小的数编号是1,第二小的编号2,依次类推.

### 输入格式

 - 第一行二个整数N,M表示这组数有N个,然后有M 个询问
 - 第二行,N个数
 - 第三行,N个数,按原顺序输出每个数字对应的离散化后的值

### 输入样例

```
6 2
1 2 3 4 3 1000
```

### 输出样例

```
1 2 3 4 3 5
```

## 方法一

如下面的数据

```
9
1 3 3 2 100 100 100  999 888
```

我们观察数据,肯定可以这样操作

```
1 2 3 3 100 100 100 888 999
| | | |  |   |   |   |   |
1 2 3 3  4   4   4   5   5
```

每个点都可以这样进行一一对应,那我们应该如何写程序实现呢？


先读入:

```
  值: 1 3 3 2 100 100 100  999 888
下标: 1 2 3 4 5   6    7   8   9
```

排序:
```
  值: 1 2 3 3 100 100 100 888 999
下标: 1 2 3 4 5   6    7   8   9
```

去重:
```
1 2 3 4   5   6
1 2 3 100 888 999 
```

你会发现去重后下标和值的对应就是我们想要的结果

整个过程可以用这个图来解释

![1](./离散化.png)

去重的核心思想：从第二个数开始，每个数都和前一个数比较，如果和前面的数不同，就存下来


```c++
sort(a+1,a+n+1);
int fliter_common(){
    int idx = 1;
    for(i=2;i<=n;i++){ // 去重
        if(a[i] != a[i-1])  a[++idx] = a[i];
    }
    return idx; // idx代表去重后剩下的数的数量
}


基本操作1：离散化后的值对应的原来的值，想知道1对就原来的值：`a[1]`

基本操作2：数值对应的离散化后的值

这里要用到二分查找,找到第一个>=val的位置

```c
int bsearch(int l,int r,int key){
    while(l != r){
        int m = (l+r)>>1;
        if( a[m] < key) l = m+1;
        else r= m;
    }
    return l;
}
int pos = bsearch(1,n+1,val); //pos就是所求
```
### 代码
::: fold
```c
```
::: 

## 方法二:使用STL

这里主要用的是STL中的**unique()**去重函数  
其功能是去除相邻的重复元素（只保留一个），所以使用前需要对数组进行排序  
`unique(a,a+n)`返回指向超出无重复元素范围末端的下一个位置  
对于长度为n数组a，`unique(a,a+n) - a`返回的是去重后的数组长度

那它是怎么实现去重的呢？删除？  
不是，它并没有将重复的元素删除，而是把重复的元素放到数组的最后面藏起来了


 - lower_bound(it1,it2,num) 返回指向`[it1,it2)`范围内第一个大于或等于num值的迭代器
    - 如果都小于num,返回it2
 - upper_bound(it1,it2,num) 返回指向`[it1,it2)`范围内第一个大于num值的迭代器
    - 如果都小于num,返回it2

## 引用

　 - [STL之unique()去重函数](http://blog.csdn.net/tomorrowtodie/article/details/51907471)



## 使用STL 离散化

这里主要用到stl中的uique函数来进行去重

会把不相同的元素放到前面，而剩下的元素放到后面

dot

运行结束后会返回**不同元素区间**一个位置的指针

<!-- template start -->
```c
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5;
int a[maxn];
int b[maxn];
int n;

int main(){
    int i,j;
    for (i=1;i<=n;i++){
        scanf("%d",&a[i]);
        b[i] = a[i];
    }
    sort(b+1,b+n+1);
    int nn = unique(b+1,b+n+1) - b -1;
    for(i = 1;i<=n;i++){
        
        //原来的第i元素对应的新的编号
        a[i] = lower_bound(b+1,b+n+1,a[i]) - b;
    }
    for(i = 1;i<=n;i++){
        print("%d ",a[i]);
    }
    return 0;
}
```
<!-- template end -->


## 总结

::: blackboard
**离散化的本质**就是对原数组进行去重,利用二分查找找出有多少个不同的数
:::


## 练习题目
  - noip2011 铺地毯
  - noip 2013 火柴排队 前要求：求逆序对
