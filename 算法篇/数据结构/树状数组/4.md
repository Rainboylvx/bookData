---
title: "树状数组 区间最值"
date: 2019-10-09 22:39
update: 2019-10-09 22:39
author: Rainboy
cover: 
---

@[toc]

## 区间最值

![7](./bit/BITn7.png)

可以发现：对于$x$，可以直接转移到$x$的点只有，$x-2^0$，$x-2^1$，$x-2^2$，.......，$x-2^k$ ($k$满足$2^k < lowbit(x)$且$2^{k+1}>=lowbit(x)$)

### 数学原理

若$x = 1010000$

$$
\begin{matrix}
&=& 1001000 &+& lowbit(1001000) &=& 1001000 &+& 1000 &=& 1001000 &+& 2^3 \\
&=& 1001100 &+& lowbit(1001100) &=& 1001100 &+& 100  &=& 1001100 &+& 2^2 \\
&=& 1001110 &+& lowbit(1001110) &=& 1001110 &+& 10   &=& 1001110 &+& 2^1 \\
&=& 1001111 &+& lowbit(1001111) &=& 1001111 &+& 1    &=& 1001111 &+& 2^0\\
\end{matrix}
$$

## 建立 / 尾插入

利用上面的性质,在树状数组的尾部插入数据,来**建立**一个树状数组

```c
void push(int pos){
    int i,lb = lowbit(pos);
    c[pos] = a[pos];
    for(i=1;i<lb;i <<=1){
        c[pos] = max(c[pos],c[pos-i]);
    }
}
```

## update 维护树上的值

```viz-neato
<%- include("dot/max_1.dot") %>
```

```viz-neato
<%- include("dot/max_2.dot") %>
```


todo animation

```viz-neato
<%- include("dot/max_update_1.dot") %>
```

```c
//更新第pos个数
void update(int pos,int v){
    int lb,i;
    while(pos<n){
        c[pos] = a[pos]; // 直接对应的值
        lb = lowbit(pos);
        for(i=1;i<lb;i= i<<1)
            c[pos] = max(c[pos],c[pos-i]);
        pos+=lowbit(pos);
    }
}
```

设`query(x,y)`求区间[x,y]之间的最值,
已知$c[x]$表示$[x-lowbit(x)+1,x]$之间的最值,那如何求区间$[x,y]$的最值呢?

想一想:

 - [1,8], c[8]
 - [1,7], c[7],c[6],c[4]
 - [2,7], c[7],c[6],a[4],c[3],a[2]
 - [2,2], a[2]

假如要求$[2,8]$的最值.


 - 若$y-lowbit(y)+1 >=x$,则$query(x,y) = max(c[y],query(x,y-lowbit(y)))$;
 - 若$y-lowbit(y)+1 <x$,则$query(x,y) = max(a[y],query(x,y-1))$;
 - 边界$x > y$

## 练习题目

 - hdu 1754
