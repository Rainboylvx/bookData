## 次优解与第k优解
对于求次优解、第K优解类的问题，如果相应的最优解问题能写出状态转移方程、用动态规划解决，那么求次优解往往可以相同的复杂度解决，第K优解则比求最优解的复杂度上多一个系数K。

其基本思想是将每个状态都表示成有序队列，将状态转移方程中的max/min转化成有序队列的合并。这里仍然以01背包为例讲解一下。

首先看01背包求最优解的状态转移方程：f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。如果要求第K优解，那么状态f[i][v]就应该是一个大小为K的数组f[i][v][1..K]。其中f[i][v][k]表示前i个物品、背包大小为v时，第k优解的值。“f[i][v]是一个大小为K的数组”这一句，熟悉C语言的同学可能比较好理解，或者也可以简单地理解为在原来的方程中加了一维。显然f[i][v][1..K]这K个数是由大到小排列的，所以我们把它认为是一个有序队列。

然后原方程就可以解释为：f[i][v]这个有序队列是由f[i-1][v]和f[i-1][v-c[i]]+w[i]这两个有序队列合并得到的。有序队列f[i-1][v]即f[i-1][v][1..K]，f[i-1][v-c[i]]+w[i]则理解为在f[i-1][v-c[i]][1..K]的每个数上加上w[i]后得到的有序队列。合并这两个有序队列并将结果的前K项储存到f[i][v][1..K]中的复杂度是O(K)。最后的答案是f[N][V][K]。总的复杂度是O(VNK)。

为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为K的数组，并在这个数组中有序的保存该状态可取到的前K个最优值。那么，对于任两个状态的max运算等价于两个由大到小的有序队列的合并。

另外还要注意题目对于“第K优解”的定义，将策略不同但权值相同的两个方案是看作同一个解还是不同的解。如果是前者，则维护有序队列时要保证队列里的数没有重复的。


## 核心代码


```c
		int i,j,t;
		for(i=0;i<n;i++) //对每个物品扫描
			for(j=v;j>=vol[i];j--) //对每个状态进行更新 
			{
				for(t=1;t<=k;t++)
				{ //把所有可能的解都存起来
					a[t]=f[j][t];
					b[t]=f[j-vol[i]][t]+val[i];
				}
				int m,x,y;
				m=x=y=1;
				a[k+1]=b[k+1]=-1;
				//下面的循环相当于求a和b并集，也就是所有的可能解 
				while(m<=k && (a[x]!=-1 || b[y]!=-1))
				{
					if(a[x]>b[y])
						f[j][m]=a[x++];
					else 
						f[j][m]=b[y++];	
					if(f[j][m]!=f[j][m-1])
						m++;
				}
			}
```


 - [Bone Collector II  Bone Collector II ](https://vjudge.net/problem/hdu-2639)
