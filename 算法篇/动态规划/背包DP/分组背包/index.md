---
_id: "0194615851"
title: 分组背包/序
date: 2020-01-26 20:34
update: 2020-01-26 20:34
author: Rainboy
---


@[toc]

## 分组背包/题目

有N组物品,背包的容量C,在每组物品最多选一个的前提下,是背包内装的物品价值最大.

设$w_{ij},v_{ij}$表示第i组第j个物品的重量与价值.$cnt_{i}$表示第i组物品的数量.

- 第1行:背包的容量C
- 第2行:有N组物品
- 接下来每组物品的数量num[i]
    - 有num[i]行物品的描述
    - 每一行两个数:重量,价值

```
3
2
3
1 1
2 2
3 3
3
1 3
2 2
3 1
```

## 解析

这里和01背包的区别是,组内最多选一个(也可能一个也不选),只要**保证组内最多选一个**即可

$f[i][j][k]$表示,选到第i组第j个物品,在容量为k的前提下的最大价值

$$
f[i][j][k] = \left\{\begin{matrix}
f[i-1][num_{i-1}][k-w_{ij}]+v_{ij}\\ 
f[i][j-1][k] \\
\end{matrix}\right.
$$

每一组的边界:$f[i][0][k] = f[i-1][num_{i-1}][k]$

在同一组内迭代的时候$f[i][j][k]$



计算过程:

1. 一组一组的计算,先算第1组在各个容量下能得到的最大价值
2. 组内枚举每个物品,对每个物品,有两种可能性:
    1. 要么**不选**,同一组的前面的物品的值可能选一个
    2. 要么**选**,需要上一组的值

```c
int i,j,k;
for(i=1;i<=N;i++){ //枚举组
    for(j=1;j<=num[i];j++){ //枚举组内物品
        for(k=wij;k<=C;k++){ //枚举容量
            //第i组内的一个物品都不选
            f[i][0][k] = f[i-1][num[i-1]][k];
            f[i][j][k] = max{
                f[i][j-1][k], // 不选第j个物品,但前面的物品可能选一个
                f[i-1][num[i-1]][k-wij] + vij // 选第j个物品
            }
        }
    }
}
```



使用一维数组迭代求最大值的思想,
在同一组内迭代的时候,可以去掉j

变成二维的数组$f[i][k]$表示是前i组物品,在容量为k的条件下的最大价值

```c
int i,j,k;
for(i=1;i<=N;i++){ //枚举组
    for(j=1;j<=num[i];j++){ //枚举组内物品
        for(k=wij;k<=C;k++){ //枚举容量
            //可能的值是:组内一个都不选的值
            f[i][k] = max(f[i][k],f[i-1][k]);
            f[i][k] = max{
                f[i][k], // 不选第j个物品,但前面的物品可能选一个
                f[i-1][k-wij] + vij // 选第j个物品
            }
        }
    }
}
```

再压一维,类比01背包,观察一下求解的过程



让容量K到过来求
```c
int i,j,k;
for( i =1;i<=N;i++){
    for(j=1;j<=num[i];j++){ //枚举组内物品
        for(k=C;k>=Wij;k--){ //枚举容量
            f[k] = max{
                f[k], // 不选第j个物品,但前面的物品可能选一个
                f[k],// 第i组的物品一个都不选
                f[k-wij] + vij // 选第j个物品
            }
        }
    }
}
```

**不对**,相当于一个标准的01背包,没有体现出**组内物品最多选一个**的条件

<!-- template start -->
```c
int i,j,k;
for(i=1;i<=N;i++)
    for(K=C;k>=0 ;k--){   //先枚举容量
        for(j=1;j<=num[i];j++){ //再枚举组内物品
            if(W[i][j] > k) continue;
            f[k] = max{
                f[k],
                f[k-W[i][j]] + V[i][j]
            }
        }
    }
```
<!-- template end -->

为什么可以呢?只要我们在纸上自己画一下计算过程算出来就可以理解


<<<< viz-gallery(title="一维分组背包演示",engine="dot",height="400")

<% 
var log =[]
var engine = "dot"
for(let i=1;i<=13;i++){
    var page = `dot/fenzu_${i}.dot`
%>

``` <%= engine || ""%> <%= log[i-1] || "" %>
<%- include(page) %>
```
<%}%>

<<<<


::: blackboard
<!-- template start -->
核心思想:
按组->容量->组内物品的顺序枚举,这样就保证了:当前容量,当前组内物品
j
- 当前格子是组内前j-1个物品得到的价值,
- 前面的格子是前i组物品得到的价值
<!-- template end -->
:::
