<p style="text-align: center;font-size:35px">[NOIP2007] 纪念品分组</p>


题目地址:http://cojs.tk/cogs/problem/problem.php?pid=121

**【题目描述】**

元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。
你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。

**【输入】**

输入文件group.in包含n+2行：
第1行包括一个整数w，为每组纪念品价格之和的上限。
第2行为一个整数n，表示购来的纪念品的总件数。
第3～n+2行每行包含一个正整数`pi(5<=pi<=w)`，表示所对应纪念品的价格。

**【输出】**

输出文件group.out仅一行，包含一个整数，即最少的分组数目。

**【输入样例】**

```
100
9
90
20
20
30
50
60
70
80
90
```

**【输出样例】**

6

**【限制】**

50％的数据满足：l<=n<=15

100％的数据满足：1<=n<=30000，80<=w<=200

## 分析

只要尽可能的分成两个一组,这样分成的组数就会尽可能的少.这是一个贪心算法.

贪心原则:每个物品找和能和自己组成一组的最大的另一个物品,如果找不到就自己一组.

最多有3000个数,怎么能最快的从中找到**某个范围内的数**?如果按上面的**原则**来我们要找到一个范围内的数(二分查找上界),能不能更简单呢?

简单的思考一下,把上面的说法改成:

把物品大到小排序,第一个物品是最大,它能不能和最小的物品形成一组(那第二大的物品就有可能和第二大的物品形成一组),否则第一个物品单独成一组.

贪心策略:排序,大的物品从小的开始挑选.

```c
/*============================================================================
* Title : [NOIP2007] 纪念品分组
* Author: Rainboy
* Time  : 2016-05-06 14:48
* update: 2016-05-06 14:48
* © Copyright 2016 Rainboy. All Rights Reserved.
*=============================================================================*/
#include <cstdio>

int n,m;

int a[30010]={0};

void quicksort(int l,int r){
    if( l < r){
        int key = a[l];
        int i=l,j=r;
        while(i<j){
            while(i<j && a[j] >= key) j--;
            if(i < j) a[i++] =a[j];
            while(i < j && a[i] <= key) i++;
            if( i <j ) a[j--] = a[i];
        }
        a[i] = key;
        quicksort(l,i-1);
        quicksort(i+1,r);
    }
}

int main(){
    int i,j,k;
    scanf("%d%d",&n,&m);

    for (i=1;i<=m;i++){
        scanf("%d",&a[i]);
    }

    quicksort(1,m);

    int sum=0;
    j=1; //指向小的数据的下标
    for (i=m;i>j;i--){
        if( a[i] + a[j] <= n){
            j++;
            sum++;
        } else {
            sum++;
        }
    }

    /* 看看最后有没有  剩下来的*/
    /* 如果最后 剩下一个物品 i==j 如果没有剩下物品 j>i*/
    if(i == j)
        sum++;
    printf("%d",sum);
    return 0;
}

```
