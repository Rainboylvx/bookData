---
title: 最优贸易
date: 2019-07-03 09:07
update: 2019-07-03 09:07
author: Rainboy
---


## 解析

## 代码


```c
/*-----------------
* author: Rainboy
* email: rainboylvx@qq.com
* time: 2019年 05月 09日 星期四 11:21:43 CST
* problem: noip2009-题目3:最优贸易
*   
*   使用 两遍 spfa
*----------------*/
#include <cstdio>
#include <vector>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;

#define maxn 100005

int n,m;
int p[maxn];

int _fmin[maxn]; //从起点1 到点i的最小点值
int dp[maxn]; //从起点1 到点i的最大收益



struct xlx{
    int edge_cnt=0;
    vector<int> head;
    vector<int> V;
    vector<int> U;
    vector<int> W;
    vector<int> next;

    /* 构造函数,点的数量 */
    xlx(int n){
        head = vector<int> (n,-1);
    }

    void add_edge(int u,int v,int w){
        U.push_back(u);
        V.push_back(v);
        W.push_back(w);
        next.push_back( head[u]);
        head[u] = edge_cnt;
        edge_cnt++;
    }

    void add_edge(int u,int v){
        U.push_back(u);
        V.push_back(v);
        next.push_back( head[u]);
        head[u] = edge_cnt;
        edge_cnt++;
    }
};

xlx x(maxn);


void init(){
    memset(_fmin,0x7f,sizeof(_fmin));
    scanf("%d%d",&n,&m);
    int i;
    for (i=1;i<=n;i++){
        scanf("%d",&p[i]);
    }

    int t1,t2,t3;
    for (i=1;i<=m;i++){
        scanf("%d%d%d",&t1,&t2,&t3);
        x.add_edge(t1,t2);
        if( t3 > 1)
            x.add_edge(t2,t1);
    }
}

queue<int> q;
bool in_q[maxn];

void spfa__fmin(int s){
    memset(in_q,0,sizeof(in_q));
    _fmin[s] = p[s]; //起点
    in_q[s] = 1;
    q.push(s);

    while(!q.empty()){
        int u = q.front(); q.pop();

        in_q[u] = 0;

        int i;
        for(i=x.head[u];i!=-1;i= x.next[i]){
            int v = x.V[i];
            int t= min(_fmin[u],p[v]);
            if( _fmin[v] > t){
                _fmin[v] = t;
                if( !in_q[v]){
                    in_q[v] = 1;
                    q.push(v);
                }
            }
        }
    }
}

void spfa_dp(int s){
    memset(in_q,0,sizeof(in_q));
    dp[s] = 0;
    in_q[s] = 1;
    q.push(s);

    while(!q.empty()){

        int u = q.front(); q.pop();

        in_q[u] = 0;

        int i;
        for(i=x.head[u];i!=-1;i= x.next[i]){
            int v = x.V[i];
            int t = max(p[v]-_fmin[v],dp[u]);
            if( dp[v] < t){
                dp[v] = t;
                if( !in_q[v] ){
                    in_q[v] = 1;
                    q.push(v);
                }
            }
        }
    }
}


int main(){
    init();
    spfa__fmin(1);
    spfa_dp(1);
    printf("%d",dp[n]);
    return 0;
}
```

