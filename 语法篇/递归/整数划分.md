## 问题

[roj上的本题](<%- USER.ROJ_P%>5000)

对于一个正整数n的分化，就是把n表示成一系列正整数之和的表达式。注意，分化与顺序无关，例如6=5+1和6=1+5是一样的。N本身也是一个划分。
例如：对于n=6

```
6
5+1
4+2     4+1+1
3+3     3+2+1       3+2+1+1
2+2+2   2+2+1+1     2+1+1+1+1
1+1+1+1+1+1
```
求分化的数目p(n)，显然$p(6) = 11$

## 解析

不知道如何下手，把所有的数据都写一下，找一下规律，找规律是一种很常用的方法。

对于1

```
1
```

对于2

```
2
1+1
```

对于3

```
3
2+1
1+1+1
```

对于4

```
4
3+1
2+2 2+1+1
1+1+1+1
```

对于5

```
5
4+1
3+2 3+1+1
2+2+1 2+1+1+1
1+1+1+1+1
```

对于6

```
6
5+1
4+2     4+1+1
3+3     3+2+1       3+2+1+1
2+2+2   2+2+1+1     2+1+1+1+1
1+1+1+1+1+1
```

对于7

```
7
6+1
5+2 5+1+1
4+3 4+2+1 4+1+1+1
3+3+1 3+2+2 3+2+1+1 3+1+1+1+1
2+2+2+1 2+2+1+1+1 2+1+1+1+1+1
1+1+1+1+1+1+1+1
```
通过对上面的数据的观察， 设$f(n,m)$表示把$n$分解成不超过$m$的分法的数量，可以得到下面的规律。


显示$f(n,1)= 1$

 - $f(n,n) = 1+f(1,n-1) + f(2,n-2)+ \cdots +f(n-1,1)$
 - 当$m>n$时，$f(n,m) = f(n,n)$
 - 当$m<n$时，$f(n,m) = f(n-m,m)+ f(n-(m-1),m-1) + \cdots + f(n-1,1)$

## 代码

```c
#include <cstdio>

int n;
int dfs(int n,int m){
    if( m > n ) m = n;
    if( m == 1) return 1;
    int ans = 0;
    if( m == n) ans=1,m=n-1;
    for(int i = m ; i>=1;i--){
        int d = dfs(n-i,i);
        ans +=d;
    }
    return ans;
}
int main(){
    scanf("%d",&n);//输入数字
    int ans = dfs(n,n);
    printf("%d\n",ans);
    return 0;
}
```

